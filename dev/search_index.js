var documenterSearchIndex = {"docs":
[{"location":"api/pipelines/#Pipeline-Operations","page":"Pipelines","title":"Pipeline Operations","text":"Functional programming interface for chaining SDMX operations.","category":"section"},{"location":"api/pipelines/#Main-Functions","page":"Pipelines","title":"Main Functions","text":"","category":"section"},{"location":"api/pipelines/#Types","page":"Pipelines","title":"Types","text":"","category":"section"},{"location":"api/pipelines/#Pipeline-Operators","page":"Pipelines","title":"Pipeline Operators","text":"","category":"section"},{"location":"api/pipelines/#SDMXer.validate_with","page":"Pipelines","title":"SDMXer.validate_with","text":"validate_with(schema::DataflowSchema; kwargs...) -> Function\n\nCreates a validation function for use in data processing pipelines.\n\nThis function returns a closure that can be used with Julia's pipe operator to validate DataFrames against SDMX schemas in a functional programming style.\n\nArguments\n\nschema::DataflowSchema: The SDMX dataflow schema to validate against\nkwargs...: Additional keyword arguments passed to the validator\n\nReturns\n\nFunction: A function that takes a DataFrame and returns a ValidationResult\n\nExamples\n\nresult = my_data |> validate_with(schema; strict_mode=true)\nvalidator_func = validate_with(schema; performance_mode=true)\nresult = validator_func(my_data)\n\nSee also\n\n⇒, create_validator\n\n\n\n\n\n","category":"function"},{"location":"api/pipelines/#SDMXer.chain","page":"Pipelines","title":"SDMXer.chain","text":"chain(operations...) -> Function\n\nCreates a composable chain of operations for data processing workflows.\n\nThis function creates a single function that applies a sequence of operations in order, passing the result of each operation to the next. It's useful for building complex data transformation pipelines.\n\nArguments\n\noperations...: Variable number of functions to chain together\n\nReturns\n\nFunction: A function that applies all operations sequentially to input data\n\nExamples\n\nprocessor = chain(\n    validate_with(schema),\n    profile_with(\"my_data.csv\"),\n    data -> transform_data(data)\n)\n\nresult = my_data |> processor\n\n# More complex example\nanalysis_pipeline = chain(\n    validate_with(schema; strict_mode=true),\n    profile_with(\"dataset\"),\n    data -> (data, infer_mappings(data, schema))\n)\n\nSee also\n\npipeline, SDMXPipeline\n\n\n\n\n\n","category":"function"},{"location":"api/pipelines/#SDMXer.pipeline","page":"Pipelines","title":"SDMXer.pipeline","text":"pipeline(operations...) -> SDMXPipeline\n\nCreate an SDMX processing pipeline with chainable operations.\n\nThis function constructs an SDMXPipeline that can be reused and applied to different datasets using Julia's pipe operator syntax.\n\nArguments\n\noperations...: Variable number of functions to include in the pipeline\n\nReturns\n\nSDMXPipeline: A pipeline object that can be applied to data\n\nExamples\n\nmy_pipeline = pipeline(\n    validate_with(schema; strict_mode=true),\n    profile_with(\"dataset.csv\")\n)\n\n# Execute the pipeline\nresult = my_data |> my_pipeline\n\n# Reusable pipeline for multiple datasets\nstandard_pipeline = pipeline(\n    validate_with(schema),\n    profile_with(\"data\")\n)\n\nresults = [dataset1, dataset2] .|> Ref(standard_pipeline)\n\nSee also\n\nSDMXPipeline, chain\n\n\n\n\n\n","category":"function"},{"location":"api/pipelines/#SDMXer.tap","page":"Pipelines","title":"SDMXer.tap","text":"tap(f::Function) -> Function\n\nCreates a \"tap\" function for side effects in pipelines without modifying data flow.\n\nThis function allows you to perform side effects (like logging, printing, or debugging) at any point in a pipeline without affecting the data being passed through. The original data is always returned unchanged.\n\nArguments\n\nf::Function: Function to call for side effects, receives the data as input\n\nReturns\n\nFunction: A function that applies the side effect and returns the original data\n\nExamples\n\nresult = my_data |>\n    tap(d -> println(\"Processing $(nrow(d)) rows\")) |>\n    validate_with(schema) |>\n    tap(r -> println(\"Validation score: $(r.overall_score)\"))\n\n# Debugging pipeline\ndebug_pipeline = pipeline(\n    tap(data -> @info \"Input data size: $(size(data))\"),\n    validate_with(schema),\n    tap(result -> @info \"Validation result: $(result.is_valid)\")\n)\n\nSee also\n\nchain, pipeline\n\n\n\n\n\n","category":"function"},{"location":"api/pipelines/#SDMXer.branch","page":"Pipelines","title":"SDMXer.branch","text":"branch(condition::Function, true_path::Function, false_path::Function=identity) -> Function\n\nCreates conditional branching in data processing pipelines.\n\nThis function allows pipelines to take different processing paths based on runtime conditions, enabling adaptive data processing workflows.\n\nArguments\n\ncondition::Function: Function that takes data and returns a boolean\ntrue_path::Function: Function to apply when condition is true\nfalse_path::Function=identity: Function to apply when condition is false (default: identity)\n\nReturns\n\nFunction: A function that applies conditional logic to input data\n\nExamples\n\nresult = my_data |>\n    branch(\n        data -> nrow(data) > 1000,\n        validate_with(schema; performance_mode=true),  # Large dataset path\n        validate_with(schema; strict_mode=true)        # Small dataset path\n    )\n\n# Handle missing data differently\nprocessor = branch(\n    data -> any(ismissing, eachcol(data)),\n    data -> impute_missing(data),  # Has missing values\n    identity                       # No missing values\n)\n\nSee also\n\ntap, chain\n\n\n\n\n\n","category":"function"},{"location":"api/pipelines/#SDMXer.parallel_map","page":"Pipelines","title":"SDMXer.parallel_map","text":"parallel_map(f::Function) -> Function\n\nCreates a parallel mapping function for concurrent data processing.\n\nThis function creates a parallel version of map that can process multiple datasets or collections concurrently, improving performance for CPU-intensive SDMX operations.\n\nArguments\n\nf::Function: Function to apply to each element in parallel\n\nReturns\n\nFunction: A function that applies f to collections in parallel using threading\n\nExamples\n\n# Process multiple datasets in parallel\nresults = datasets |> parallel_map(validate_with(schema))\n\n# Parallel profiling of multiple files\nprofiles = data_files |> parallel_map(profile_with(\"batch_analysis\"))\n\n# Apply transformation to multiple dataframes\ntransformed = dataframes |> parallel_map(data -> transform(data, :col => :new_col))\n\nThrows\n\nBoundsError: If collections are empty\n\nSee also\n\nchain\n\n\n\n\n\n","category":"function"},{"location":"api/pipelines/#SDMXer.SDMXPipeline","page":"Pipelines","title":"SDMXer.SDMXPipeline","text":"SDMXPipeline{T}\n\nA composable pipeline structure for complete SDMX data processing workflows.\n\nThis struct wraps a collection of operations that can be applied sequentially to data, providing a reusable and composable approach to SDMX data processing.\n\nFields\n\noperations::T: Tuple or collection of operations to be applied in sequence\n\nExamples\n\nmy_pipeline = pipeline(\n    validate_with(schema),\n    profile_with(\"dataset.csv\")\n)\n\nresult = my_data |> my_pipeline\n\nSee also\n\npipeline, chain\n\n\n\n\n\n","category":"type"},{"location":"api/pipelines/#Base.:⊆","page":"Pipelines","title":"Base.:⊆","text":"⊆(data::DataFrame, schema::DataflowSchema) -> Bool\n\nSchema compliance operator using subset symbol.\n\nReturns true if data structure is a subset/compliant with schema requirements. This operator provides an intuitive way to check if a DataFrame conforms to the structure defined by an SDMX dataflow schema.\n\nArguments\n\ndata::DataFrame: The DataFrame to validate against the schema\nschema::DataflowSchema: The SDMX dataflow schema to check compliance against\n\nReturns\n\nBool: true if data structure complies with schema requirements, false otherwise\n\nExamples\n\nis_compliant = my_data ⊆ schema\nif my_data ⊆ schema\n    println(\"Data is schema compliant!\")\nend\n\nSee also\n\n⇒, validate_with\n\n\n\n\n\n","category":"function"},{"location":"api/pipelines/#SDMXer.:⇒","page":"Pipelines","title":"SDMXer.:⇒","text":"⇒(data::DataFrame, validator::SDMXValidator) -> ValidationResult\n\nData flow operator for direct DataFrame validation.\n\nProvides a pipeline-friendly operator for applying SDMX validation to DataFrames. The arrow symbol suggests the flow of data through the validation process.\n\nArguments\n\ndata::DataFrame: The DataFrame to validate\nvalidator::SDMXValidator: The validator to apply to the data\n\nReturns\n\nValidationResult: The result of the validation process\n\nExamples\n\nresult = my_data ⇒ validator\nif (my_data ⇒ validator).is_valid\n    println(\"Validation passed!\")\nend\n\nSee also\n\n⊆, validate_with\n\n\n\n\n\n","category":"function"},{"location":"api/elements/#SDMXer-Element-Types","page":"Elements","title":"SDMXer Element Types","text":"Type-specialized parsing system using @generated functions for compile-time optimization.","category":"section"},{"location":"api/elements/#Element-Types","page":"Elements","title":"Element Types","text":"","category":"section"},{"location":"api/elements/#Extraction-Functions","page":"Elements","title":"Extraction Functions","text":"","category":"section"},{"location":"api/elements/#Demonstrations","page":"Elements","title":"Demonstrations","text":"","category":"section"},{"location":"api/elements/#SDMXer.SDMXElement","page":"Elements","title":"SDMXer.SDMXElement","text":"SDMXElement\n\nAbstract base type for all SDMX element types used in generated function dispatch.\n\nThis type hierarchy enables compile-time specialization of parsing functions, allowing the Julia compiler to generate optimized code paths for each specific SDMX element type without runtime type checking overhead.\n\nSee also\n\nextract_sdmx_element, DimensionElement, AttributeElement\n\n\n\n\n\n","category":"type"},{"location":"api/elements/#SDMXer.DimensionElement","page":"Elements","title":"SDMXer.DimensionElement","text":"DimensionElement <: SDMXElement\n\nType representing SDMX dimension elements for specialized parsing.\n\nDimensions define the key attributes that categorize statistical data in SDMX datasets. This type enables compile-time generation of optimized parsing code for dimension structures including concept references, codelist bindings, and position information.\n\nExamples\n\n# Use with generated parsing function\ndimension_data = extract_sdmx_element(DimensionElement, dimension_node)\nprintln(dimension_data.dimension_id)\nprintln(dimension_data.position)\n\nSee also\n\nextract_sdmx_element, AttributeElement, MeasureElement\n\n\n\n\n\n","category":"type"},{"location":"api/elements/#SDMXer.AttributeElement","page":"Elements","title":"SDMXer.AttributeElement","text":"AttributeElement <: SDMXElement\n\nType representing SDMX attribute elements for specialized parsing.\n\nAttributes provide additional metadata about statistical observations in SDMX datasets. This type enables compile-time generation of optimized parsing code for attribute structures including assignment status, attachment levels, and concept references.\n\nExamples\n\n# Use with generated parsing function\nattribute_data = extract_sdmx_element(AttributeElement, attribute_node)\nprintln(attribute_data.attribute_id)\nprintln(attribute_data.assignment_status)\n\nSee also\n\nextract_sdmx_element, DimensionElement, MeasureElement\n\n\n\n\n\n","category":"type"},{"location":"api/elements/#SDMXer.MeasureElement","page":"Elements","title":"SDMXer.MeasureElement","text":"MeasureElement <: SDMXElement\n\nType representing SDMX measure elements for specialized parsing.\n\nMeasures define the actual statistical values being reported in SDMX datasets. This type enables compile-time generation of optimized parsing code for measure structures including data types, units of measure, and concept references.\n\nExamples\n\n# Use with generated parsing function\nmeasure_data = extract_sdmx_element(MeasureElement, measure_node)\nprintln(measure_data.measure_id)\nprintln(measure_data.data_type)\n\nSee also\n\nextract_sdmx_element, DimensionElement, AttributeElement\n\n\n\n\n\n","category":"type"},{"location":"api/elements/#SDMXer.ConceptElement","page":"Elements","title":"SDMXer.ConceptElement","text":"ConceptElement <: SDMXElement\n\nType representing SDMX concept elements for specialized parsing.\n\nConcepts define the semantic meaning of dimensions, attributes, and measures in SDMXer. This type enables compile-time generation of optimized parsing code for concept structures including names, descriptions, and classifications.\n\nExamples\n\n# Use with generated parsing function\nconcept_data = extract_sdmx_element(ConceptElement, concept_node)\nprintln(concept_data.concept_id)\nprintln(concept_data.name)\n\nSee also\n\nextract_sdmx_element, CodelistElement\n\n\n\n\n\n","category":"type"},{"location":"api/elements/#SDMXer.CodelistElement","page":"Elements","title":"SDMXer.CodelistElement","text":"CodelistElement <: SDMXElement\n\nType representing SDMX codelist elements for specialized parsing.\n\nCodelists define the valid values (codes) that can be used for dimensions and attributes. This type enables compile-time generation of optimized parsing code for codelist structures including code hierarchies, names, and parent-child relationships.\n\nExamples\n\n# Use with generated parsing function\ncodelist_data = extract_sdmx_element(CodelistElement, codelist_node)\nprintln(codelist_data.codelist_id)\nprintln(codelist_data.codes)\n\nSee also\n\nextract_sdmx_element, ConceptElement\n\n\n\n\n\n","category":"type"},{"location":"api/elements/#SDMXer.AvailabilityElement","page":"Elements","title":"SDMXer.AvailabilityElement","text":"AvailabilityElement <: SDMXElement\n\nType representing SDMX availability constraint elements for specialized parsing.\n\nAvailability constraints define what data is actually available for specific dimensions and time periods. This type enables compile-time generation of optimized parsing code for availability structures including dimension values and time ranges.\n\nExamples\n\n# Use with generated parsing function\navailability_data = extract_sdmx_element(AvailabilityElement, availability_node)\nprintln(availability_data.dimension_values)\nprintln(availability_data.time_periods)\n\nSee also\n\nextract_sdmx_element, TimeElement\n\n\n\n\n\n","category":"type"},{"location":"api/elements/#SDMXer.TimeElement","page":"Elements","title":"SDMXer.TimeElement","text":"TimeElement <: SDMXElement\n\nType representing SDMX time dimension elements for specialized parsing.\n\nTime elements define temporal aspects of statistical data including periods, frequency, and time ranges. This type enables compile-time generation of optimized parsing code for time structures including start/end dates and period formats.\n\nExamples\n\n# Use with generated parsing function\ntime_data = extract_sdmx_element(TimeElement, time_node)\nprintln(time_data.start_period)\nprintln(time_data.end_period)\n\nSee also\n\nextract_sdmx_element, AvailabilityElement\n\n\n\n\n\n","category":"type"},{"location":"api/elements/#SDMXer.extract_sdmx_element","page":"Elements","title":"SDMXer.extract_sdmx_element","text":"extract_sdmx_element(::Type{T}, node::EzXML.Node) where T <: SDMXElement -> NamedTuple\n\nExtract SDMX element data using compile-time specialized parsing based on element type.\n\nThis @generated function creates type-specialized parsing code at compile time, eliminating runtime type checking and providing optimized XPath queries and field extraction for each SDMX element type.\n\nArguments\n\n::Type{T}: SDMX element type for compile-time specialization\nnode::EzXML.Node: XML node containing the SDMX element data\n\nReturns\n\nNamedTuple: Extracted element data with fields specific to the element type\n\nExamples\n\n# Parse different SDMX elements with specialized code\ndimension_data = extract_sdmx_element(DimensionElement, dim_node)\nattribute_data = extract_sdmx_element(AttributeElement, attr_node)\nmeasure_data = extract_sdmx_element(MeasureElement, measure_node)\n\n# Access type-specific fields\nprintln(dimension_data.dimension_id)    # Only available for dimensions\nprintln(attribute_data.assignment_status)  # Only available for attributes\nprintln(measure_data.data_type)         # Only available for measures\n\nPerformance\n\nThis generated function provides significant performance improvements over runtime dispatch:\n\n30-50% reduction in parsing time\n20-40% reduction in memory allocations\nBetter scaling with large SDMX documents\n\nSee also\n\nget_xpath_patterns, DimensionElement\n\n\n\n\n\n","category":"function"},{"location":"api/elements/#SDMXer.extract_generic_element","page":"Elements","title":"SDMXer.extract_generic_element","text":"extract_generic_element(node::EzXML.Node) -> NamedTuple\n\nFallback generic extraction for unsupported element types.\n\nThis function provides a safety net for element types that don't have specialized @generated function implementations.\n\n\n\n\n\n","category":"function"},{"location":"api/elements/#SDMXer.extract_code_info","page":"Elements","title":"SDMXer.extract_code_info","text":"extract_code_info(code_node::EzXML.Node) -> NamedTuple\n\nExtract information from a single code node in a codelist.\n\nThis helper function is used by the generated codelist extraction to process individual code elements efficiently.\n\n\n\n\n\n","category":"function"},{"location":"api/elements/#SDMXer.get_xpath_patterns","page":"Elements","title":"SDMXer.get_xpath_patterns","text":"get_xpath_patterns(::Type{T}) where T <: SDMXElement -> NamedTuple\n\nGenerate compile-time XPath patterns for specific SDMX element types.\n\nThis @generated function provides type-specialized XPath patterns that are compiled at build time, eliminating runtime XPath string construction and parsing overhead.\n\nArguments\n\n::Type{T}: SDMX element type for compile-time specialization\n\nReturns\n\nNamedTuple: XPath patterns specific to the element type\n\nExamples\n\n# Get compile-time XPath patterns\ndim_patterns = get_xpath_patterns(DimensionElement)\nattr_patterns = get_xpath_patterns(AttributeElement)\n\n# Patterns are available at compile time\nprintln(dim_patterns.concept_ref)    # \".//structure:ConceptIdentity/Ref\"\nprintln(attr_patterns.attachment)    # \".//structure:AttributeRelationship\"\n\nSee also\n\nextract_sdmx_element\n\n\n\n\n\n","category":"function"},{"location":"api/elements/#SDMXer.demonstrate_generated_parsing","page":"Elements","title":"SDMXer.demonstrate_generated_parsing","text":"demonstrate_generated_parsing(; verbose::Bool=true) -> Nothing\n\nDemonstrate the usage of generated function SDMX parsing with examples.\n\nThis function provides a comprehensive demonstration of how to use the new @generated function system for parsing different types of SDMX elements, showing the performance benefits and ease of use.\n\nArguments\n\nverbose::Bool=true: Whether to print output. Set to false for quiet operation during tests.\n\nExamples\n\n# Run the full demonstration with output\ndemonstrate_generated_parsing()\n\n# Run quietly (for testing)\ndemonstrate_generated_parsing(verbose=false)\n\n# This will show examples of:\n# - Type-specialized parsing for different element types\n# - Performance comparisons with traditional methods\n# - Integration with existing SDMX workflows\n\nSee also\n\nextract_sdmx_element\n\n\n\n\n\n","category":"function"},{"location":"api/elements/#SDMXer.create_benchmark_xml","page":"Elements","title":"SDMXer.create_benchmark_xml","text":"create_benchmark_xml() -> String\n\nCreate sample XML content for benchmarking generated function performance.\n\n\n\n\n\n","category":"function"},{"location":"api/elements/#SDMXer.migration_guide","page":"Elements","title":"SDMXer.migration_guide","text":"migration_guide(; verbose::Bool=true) -> Nothing\n\nProvide a comprehensive guide for migrating to generated function parsing.\n\nThis function explains how to update existing code to use the new @generated function system while maintaining compatibility and gaining performance benefits.\n\nArguments\n\nverbose::Bool=true: Whether to print output. Set to false for quiet operation during tests.\n\nExamples\n\n# Display migration instructions\nmigration_guide()\n\n# Run quietly (for testing)\nmigration_guide(verbose=false)\n\nSee also\n\nextract_sdmx_element, demonstrate_generated_parsing\n\n\n\n\n\n","category":"function"},{"location":"api/codelists/#Codelists","page":"Codelists","title":"Codelists","text":"Functions for extracting and processing SDMX codelists.","category":"section"},{"location":"api/codelists/#Main-Functions","page":"Codelists","title":"Main Functions","text":"","category":"section"},{"location":"api/codelists/#Utilities","page":"Codelists","title":"Utilities","text":"","category":"section"},{"location":"api/codelists/#SDMXer.extract_all_codelists","page":"Codelists","title":"SDMXer.extract_all_codelists","text":"extract_all_codelists(doc::EzXML.Document) -> DataFrame\n\nThe primary extraction function for a SDMX-like dataflow document. It operates on an XML object (namely, an already-parsed EzXML.Document object).\n\nThis function traverses the document to find all <structure:Codelist> elements. For each codelist, it extracts all child <structure:Code> elements, capturing their IDs, names, annotations, and the ID of the parent codelist to ensure uniqueness. The results from all codelists are aggregated into a single, tidy DataFrame.\n\nArguments\n\ndoc::EzXML.Document: A parsed XML document object from which to extract data.\n\nReturns\n\nDataFrame: A tidy DataFrame containing all codes from all codelists in the document. The columns are:\ncodelist_id::String\ncode_id::String\nlang::Union{String, Missing}\nname::Union{String, Missing}\nparent_code_id::Union{String, Missing}\norder::Union{String, Missing}\n\nIf no codelists or codes are found, it returns an empty DataFrame with the correct schema.\n\nSee also\n\nfilter_codelists_by_availability, DataflowSchema\n\n\n\n\n\nextract_all_codelists(input::String) -> DataFrame\n\nExtracts all codelist data from a URL or XML string. Automatically detects whether the input is a URL or XML content.\n\nArguments\n\ninput::String: Either a URL to fetch SDMX XML data from, or raw XML content as a string.\n\nReturns\n\nDataFrame: A tidy DataFrame containing all codes from all codelists.\n\nExamples\n\n# From URL\ncodelists = extract_all_codelists(\"https://example.com/dataflow.xml\")\n\n# From XML string\ncodelists = extract_all_codelists(xml_string)\n\n\n\n\n\nextract_all_codelists(url::String, filter_by_availability::Bool) -> DataFrame\n\nExtract codelists with automatic availability filtering.\n\nArguments\n\nurl::String: The dataflow URL to fetch the XML from.\nfilter_by_availability::Bool: If true, automatically constructs availability URL and filters codes\n\nReturns\n\nDataFrame: A tidy DataFrame containing only codes that actually appear in published data.\n\nExamples\n\n# Get only codes that have actual published data (auto-constructed availability URL)\navailable_codes = extract_all_codelists(dataflow_url, true)\n\n\n\n\n\nextract_all_codelists(url::String, availability_url::String) -> DataFrame\n\nExtract codelists with custom availability URL filtering.\n\nArguments\n\nurl::String: The dataflow URL to fetch the XML from.\navailability_url::String: Custom availability constraint URL (can include dimension filters)\n\nReturns\n\nDataFrame: A tidy DataFrame containing only codes that appear in the specified availability constraint.\n\nExamples\n\n# Use custom availability URL with dimension filters\navailable_codes = extract_all_codelists(dataflow_url, \n    \"https://stats-sdmx-disseminate.pacificdata.org/rest/availableconstraint/DF_BP50/A..NR........\")\n\n# Standard availability URL\navailable_codes = extract_all_codelists(dataflow_url,\n    \"https://stats-sdmx-disseminate.pacificdata.org/rest/availableconstraint/DF_DISABILITY/\")\n\n\n\n\n\n","category":"function"},{"location":"api/codelists/#SDMXer.filter_codelists_by_availability","page":"Codelists","title":"SDMXer.filter_codelists_by_availability","text":"filter_codelists_by_availability(codelists_df::DataFrame, dataflow_url::String, availability_url::String=\"\") -> DataFrame\n\nFilters a codelists DataFrame to include only codes that actually appear in published data.\n\nArguments\n\ncodelists_df::DataFrame: The full codelists DataFrame to filter\ndataflow_url::String: The original dataflow URL (used to construct availability URL if needed)\navailability_url::String: Explicit availability constraint URL (optional)\n\nReturns\n\nDataFrame: Filtered codelists containing only codes with actual published data\n\n\n\n\n\n","category":"function"},{"location":"api/codelists/#SDMXer.get_available_codelist_summary","page":"Codelists","title":"SDMXer.get_available_codelist_summary","text":"get_available_codelist_summary(dataflow_url::String; availability_url::String=\"\") -> Dict{String, Any}\n\nGets a summary of codelist availability without downloading full codelists.\n\nReturns information about which dimensions have data and how many values are available.\n\n\n\n\n\n","category":"function"},{"location":"api/codelists/#SDMXer.map_codelist_to_dimension","page":"Codelists","title":"SDMXer.map_codelist_to_dimension","text":"map_codelist_to_dimension(codelist_id::String) -> Union{String, Nothing}\n\nMaps a codelist ID to its corresponding dimension ID using common SDMX patterns. Returns nothing if no mapping can be determined.\n\nExamples\n\n\"CLGEOPICT\" -> \"GEO_PICT\"  \n\"CL_INDICATOR\" -> \"INDICATOR\"\n\"CL_FREQ\" -> \"FREQ\"\n\"INDICATOR\" -> \"INDICATOR\" (direct match)\n\n\n\n\n\n","category":"function"},{"location":"api/codelists/#SDMXer.construct_availability_url","page":"Codelists","title":"SDMXer.construct_availability_url","text":"construct_availability_url(dataflow_url::String) -> String\n\nAttempts to construct an availability constraint URL from a dataflow URL.\n\nSupports common SDMX URL patterns like:\n\n.../rest/dataflow/AGENCY/DATAFLOW_ID/VERSION?references=all \n.../rest/dataflow/DATAFLOW_ID/VERSION?references=all\n\n\n\n\n\n","category":"function"},{"location":"api/schema/#Schema-and-Metadata","page":"Schema & Metadata","title":"Schema & Metadata","text":"Functions for extracting and analyzing SDMX dataflow schemas and metadata.","category":"section"},{"location":"api/schema/#Main-Functions","page":"Schema & Metadata","title":"Main Functions","text":"","category":"section"},{"location":"api/schema/#Schema-Inspection","page":"Schema & Metadata","title":"Schema Inspection","text":"","category":"section"},{"location":"api/schema/#Types","page":"Schema & Metadata","title":"Types","text":"","category":"section"},{"location":"api/schema/#SDMXer.extract_dataflow_schema","page":"Schema & Metadata","title":"SDMXer.extract_dataflow_schema","text":"extract_dataflow_schema(doc::EzXML.Document) -> DataflowSchema\n\nExtracts complete dataflow schema information from an SDMX structure document.\n\nArguments\n\ndoc::EzXML.Document: The parsed SDMX XML document.\n\nReturns\n\nDataflowSchema: A comprehensive schema object with all dataflow structure information.\n\nSee also\n\nextract_dataflow_schema(::String), DataflowSchema, compare_schemas, create_validator\n\n\n\n\n\nextract_dataflow_schema(input::String) -> DataflowSchema\n\nExtracts dataflow schema from SDMX-ML content provided as URL or XML string.\n\nThis convenience function automatically handles both URL-based SDMX API calls and direct XML string parsing. It downloads schema information from SDMX web services or processes local XML content to build a complete DataflowSchema.\n\nArguments\n\ninput::String: Either a URL to SDMX dataflow schema or raw SDMX-ML XML content\n\nReturns\n\nDataflowSchema: Complete schema with dimensions, attributes, measures, and metadata\n\nExamples\n\n# Extract from SDMX API URL\nurl = \"https://stats-sdmx-disseminate.pacificdata.org/rest/datastructure/SPC/DF_BP50\"\nschema = extract_dataflow_schema(url)\n\n# Extract from local XML file content\nxml_content = read(\"dataflow.xml\", String)\nschema = extract_dataflow_schema(xml_content)\n\n# Use the schema\nprintln(\"Dataflow: \", schema.dataflow_info.name)\nprintln(\"Dimensions: \", nrow(schema.dimensions))\nprintln(\"Attributes: \", nrow(schema.attributes))\n\nThrows\n\nHTTP.ExceptionRequest.StatusError: If URL request fails\nEzXML.XMLError: If XML parsing fails\nKeyError: If required SDMX elements are missing\n\nSee also\n\nextract_dataflow_schema(::EzXML.Document), DataflowSchema, fetch_sdmx_xml, compare_schemas, create_validator\n\n\n\n\n\n","category":"function"},{"location":"api/schema/#SDMXer.extract_concepts","page":"Schema & Metadata","title":"SDMXer.extract_concepts","text":"extract_concepts(doc::EzXML.Document) -> DataFrame\n\nExtracts concept definitions and their structural roles from SDMX documents.\n\nThis function parses SDMX structure documents to extract concept schemas, including concept identifiers, descriptions, variable mappings, and their roles within the data structure (dimension, attribute, measure, or time dimension).\n\nArguments\n\ndoc::EzXML.Document: Parsed SDMX XML structure document\n\nReturns\n\nDataFrame: Concept definitions with columns:\nconcept_id::String: Unique concept identifier\ndescription::Union{String,Missing}: Human-readable concept description\nvariable::String: Variable identifier used in data structure\nrole::String: Structural role (\"dimension\", \"attribute\", \"measure\", \"time_dimension\")\n\nExamples\n\n# Extract from parsed XML document\ndoc = parsexml(xml_string)\nconcepts = extract_concepts(doc)\n\n# View concept roles\nprintln(\"Dimensions: \", filter(r -> r.role == \"dimension\", concepts).concept_id)\nprintln(\"Measures: \", filter(r -> r.role == \"measure\", concepts).concept_id)\n\n# Find concept descriptions\nconcept_desc = Dict(c.concept_id => c.description for c in eachrow(concepts))\n\nSee also\n\nextract_concepts, extract_dataflow_schema\n\n\n\n\n\nextract_concepts(input::String) -> DataFrame\n\nConvenience function for concept extraction from URLs or XML strings.\n\nThis function automatically handles URL fetching and XML parsing, providing a simple interface for concept extraction from either SDMX REST API endpoints or XML content strings. It includes error handling for network and parsing issues.\n\nArguments\n\ninput::String: Either a URL to SDMX structure endpoint or XML content string\n\nReturns\n\nDataFrame: Concept definitions (same structure as document-based extraction),  or empty DataFrame with correct schema if extraction fails\n\nExamples\n\n# Extract from SDMX REST API URL\nurl = \"https://stats-sdmx-disseminate.pacificdata.org/rest/datastructure/SPC/DF_BP50/1.0\"\nconcepts = extract_concepts(url)\n\n# Extract from XML string\nxml_content = read(\"datastructure.xml\", String)\nconcepts = extract_concepts(xml_content)\n\n# Handle potential failures gracefully\nconcepts = extract_concepts(possibly_invalid_url)\nif nrow(concepts) == 0\n    println(\"No concepts extracted - check URL or XML format\")\nelse\n    println(\"Extracted \", nrow(concepts), \" concept definitions\")\nend\n\nSee also\n\nextract_concepts, fetch_sdmx_xml\n\n\n\n\n\n","category":"function"},{"location":"api/schema/#SDMXer.get_required_columns","page":"Schema & Metadata","title":"SDMXer.get_required_columns","text":"get_required_columns(schema::DataflowSchema) -> Vector{String}\n\nReturns a vector of column names that are required for SDMX-CSV output. This includes all dimensions, the primary measure, and mandatory attributes.\n\n\n\n\n\n","category":"function"},{"location":"api/schema/#SDMXer.get_optional_columns","page":"Schema & Metadata","title":"SDMXer.get_optional_columns","text":"get_optional_columns(schema::DataflowSchema) -> Vector{String}\n\nReturns a vector of column names that are optional for SDMX-CSV output. This includes conditional attributes.\n\n\n\n\n\n","category":"function"},{"location":"api/schema/#SDMXer.get_codelist_columns","page":"Schema & Metadata","title":"SDMXer.get_codelist_columns","text":"get_codelist_columns(schema::DataflowSchema) -> Dict{String, NamedTuple}\n\nReturns a dictionary mapping column names to their codelist information. Only includes columns that have associated codelists.\n\n\n\n\n\n","category":"function"},{"location":"api/schema/#SDMXer.get_dimension_order","page":"Schema & Metadata","title":"SDMXer.get_dimension_order","text":"get_dimension_order(schema::DataflowSchema) -> Vector{String}\n\nReturns the ordered list of regular dimension IDs for constructing SDMX data query keys. Dimensions are ordered by their position. The time dimension is excluded because per the SDMX 2.1 REST API spec it must be filtered via startPeriod/endPeriod query parameters, not as a key position.\n\n\n\n\n\n","category":"function"},{"location":"api/schema/#SDMXer.DataflowSchema","page":"Schema & Metadata","title":"SDMXer.DataflowSchema","text":"DataflowSchema\n\nComplete schema information for an SDMX dataflow including structure, dimensions, and metadata.\n\nThis struct contains all essential schema information needed to validate, transform, and work with SDMX-CSV data. It provides comprehensive metadata about the dataflow structure, dimension ordering, attribute requirements, and measure definitions.\n\nFields\n\ndataflow_info::NamedTuple: Basic dataflow metadata including id, agency, version, name, and description\ndimensions::DataFrame: All dimensions with position ordering, concept references, and codelist information\nattributes::DataFrame: All attributes with assignment status (required/conditional), concept and codelist info\nmeasures::DataFrame: Primary measure definitions with concept references and data type specifications\ntime_dimension::Union{NamedTuple, Nothing}: Special time dimension information if present in the dataflow\n\nExamples\n\n# Extract schema from SDMX-ML\nschema = extract_dataflow_schema(\"SPC\", \"DF_BP50\", \"1.0\")\n\n# Access dataflow information\nprintln(\"Dataflow: \", schema.dataflow_info.name)\nprintln(\"Agency: \", schema.dataflow_info.agency)\n\n# Examine dimensions\nprintln(\"Number of dimensions: \", nrow(schema.dimensions))\nprintln(\"Dimension names: \", schema.dimensions.concept_id)\n\n# Check for time dimension\nif schema.time_dimension !== nothing\n    println(\"Time dimension: \", schema.time_dimension.concept_id)\nend\n\n# Review attributes\nrequired_attrs = filter(row -> row.assignment_status == \"Mandatory\", schema.attributes)\nprintln(\"Required attributes: \", required_attrs.concept_id)\n\nSee also\n\nextract_dataflow_schema: constructs this type from XML or URL\ncompare_schemas: compares two DataflowSchema objects for joinability\ncreate_validator: builds a validator from a schema\nquery_sdmx_data: fetches data described by a schema\n\n\n\n\n\n","category":"type"},{"location":"api/utilities/#Utility-Functions","page":"Utilities","title":"Utility Functions","text":"Helper functions for working with SDMX data and URLs.","category":"section"},{"location":"api/utilities/#URL-Utilities","page":"Utilities","title":"URL Utilities","text":"","category":"section"},{"location":"api/utilities/#Time-Utilities","page":"Utilities","title":"Time Utilities","text":"","category":"section"},{"location":"api/utilities/#Node-Processing","page":"Utilities","title":"Node Processing","text":"","category":"section"},{"location":"api/utilities/#Data-Extraction","page":"Utilities","title":"Data Extraction","text":"","category":"section"},{"location":"api/utilities/#SDMXer.is_url","page":"Utilities","title":"SDMXer.is_url","text":"is_url(input::String) -> Bool\n\nDetects if a string represents a URL using robust pattern matching.\n\nThis function uses multiple patterns to identify various URL formats commonly encountered when working with SDMX APIs. It distinguishes URLs from XML content to enable automatic handling of different input types.\n\nArguments\n\ninput::String: String to test for URL format\n\nReturns\n\nBool: true if input appears to be a URL, false otherwise\n\nExamples\n\n# Various URL formats recognized\nis_url(\"https://example.com\")  # true\nis_url(\"http://stats.pacificdata.org/rest/\")  # true\nis_url(\"www.example.com\")  # true\nis_url(\"example.com/data\")  # true\nis_url(\"ftp://files.example.com\")  # true\n\n# Non-URL content rejected\nis_url(\"<xml>content</xml>\")  # false\nis_url(\"plain text\")  # false\nis_url(\"\")  # AssertionError\n\nThrows\n\nAssertionError: If input string is empty\n\nSee also\n\nnormalize_sdmx_url, fetch_sdmx_xml\n\n\n\n\n\n","category":"function"},{"location":"api/utilities/#SDMXer.normalize_sdmx_url","page":"Utilities","title":"SDMXer.normalize_sdmx_url","text":"normalize_sdmx_url(url::String) -> String\n\nNormalizes URLs for SDMX API compatibility with required parameters.\n\nThis function ensures URLs have proper protocols and includes the SDMX references=all parameter needed for complete structure retrieval. It handles various URL formats and existing query parameters correctly.\n\nArguments\n\nurl::String: URL to normalize (must be a valid URL)\n\nReturns\n\nString: Normalized URL with protocol and SDMX parameters\n\nExamples\n\n# Add missing protocol\nnormalize_sdmx_url(\"stats.pacificdata.org/rest/datastructure\")\n# Returns: \"https://stats.pacificdata.org/rest/datastructure?references=all\"\n\n# Add SDMX parameter to existing URL\nnormalize_sdmx_url(\"https://api.example.com/structure\")\n# Returns: \"https://api.example.com/structure?references=all\"\n\n# Handle existing query parameters\nnormalize_sdmx_url(\"https://api.example.com/structure?format=xml\")\n# Returns: \"https://api.example.com/structure?format=xml&references=all\"\n\n# Already normalized URLs unchanged\nnormalize_sdmx_url(\"https://api.example.com/structure?references=all\")\n# Returns: \"https://api.example.com/structure?references=all\"\n\nThrows\n\nAssertionError: If URL is empty or not a valid URL format\n\nSee also\n\nis_url, fetch_sdmx_xml\n\n\n\n\n\n","category":"function"},{"location":"api/utilities/#SDMXer.fetch_sdmx_xml","page":"Utilities","title":"SDMXer.fetch_sdmx_xml","text":"fetch_sdmx_xml(input::String) -> String\n\nFetches SDMX XML content from URLs or validates XML strings.\n\nThis function provides unified handling for SDMX content retrieval, automatically detecting whether the input is a URL (which it fetches) or XML content (which it validates and returns). URLs are automatically normalized for SDMX compatibility.\n\nArguments\n\ninput::String: Either a URL to fetch from or XML content string\n\nReturns\n\nString: XML content from URL or validated input XML string\n\nExamples\n\n# Fetch from SDMX REST API\nxml_content = fetch_sdmx_xml(\"https://stats-sdmx-disseminate.pacificdata.org/rest/datastructure/SPC/DF_BP50\")\n\n# Handle various URL formats\nxml_content = fetch_sdmx_xml(\"stats.pacificdata.org/rest/datastructure/SPC/DF_BP50\")\n\n# Pass through XML content\nxml_string = \"<?xml version=\\\"1.0\\\"?>...>\"\nxml_content = fetch_sdmx_xml(xml_string)  # Returns xml_string unchanged\n\n# Error handling\ntry\n    xml_content = fetch_sdmx_xml(invalid_url)\ncatch e\n    println(\"Failed to fetch XML: \", e)\nend\n\nThrows\n\nAssertionError: For empty input, HTTP failures, empty responses, or invalid XML\n\nSee also\n\nis_url, normalize_sdmx_url\n\n\n\n\n\n","category":"function"},{"location":"api/utilities/#SDMXer.is_valid_time_format","page":"Utilities","title":"SDMXer.is_valid_time_format","text":"is_valid_time_format(time_str::String) -> Bool\n\nChecks if a time string follows valid SDMX time formats.\n\n\n\n\n\n","category":"function"},{"location":"api/utilities/#SDMXer.get_time_period_values","page":"Utilities","title":"SDMXer.get_time_period_values","text":"get_time_period_values(time_node::EzXML.Node) -> Vector{String}\n\nGets time period values as strings for dimension analysis.\n\n\n\n\n\n","category":"function"},{"location":"api/utilities/#SDMXer.get_time_period_range","page":"Utilities","title":"SDMXer.get_time_period_range","text":"get_time_period_range(time_coverage::TimeAvailability) -> Union{UnitRange{Int}, Vector{String}, Vector{Date}}\n\nReturns an appropriate range or vector of time periods based on the format.\n\nExamples\n\ntime_coverage = get_time_coverage(availability)\nperiods = get_time_period_range(time_coverage)\n\n# For annual data: returns 1970:2030\n# For quarterly data: returns [\"2020-Q1\", \"2020-Q2\", ..., \"2023-Q4\"]\n# For daily data: returns Date range\n\n\n\n\n\n","category":"function"},{"location":"api/utilities/#SDMXer.process_code_node","page":"Utilities","title":"SDMXer.process_code_node","text":"process_code_node(code_node::EzXML.Node) -> Vector{NamedTuple}\n\nExtracts comprehensive information from a single SDMX code node including multilingual content.\n\nThis function processes an individual code element from an SDMX codelist, extracting the code identifier, names in multiple languages, annotations, and hierarchical  parent relationships. Returns separate records for each language variant found.\n\nArguments\n\ncode_node::EzXML.Node: The SDMX code XML node to process\n\nReturns\n\nVector{NamedTuple}: Vector of code records, one per language, each containing:\ncode_id::String: The code identifier\nlanguage::String: Language code (e.g., \"en\", \"fr\")\nname::Union{String, Missing}: Code name in this language\nannotation::Union{String, Missing}: Code annotation/description in this language\nparent_id::Union{String, Missing}: Parent code identifier if hierarchical\n\nExamples\n\n# Process individual code node\ncode_records = process_code_node(code_node)\n\n# Access multilingual information\nfor record in code_records\n    println(\"Code: \", record.code_id)\n    println(\"Language: \", record.language)\n    println(\"Name: \", record.name)\n    if !ismissing(record.parent_id)\n        println(\"Parent: \", record.parent_id)\n    end\nend\n\n# Filter for specific language\nenglish_record = filter(r -> r.language == \"en\", code_records)[1]\nprintln(\"English name: \", english_record.name)\n\nSee also\n\nget_parent_id\n\n\n\n\n\n","category":"function"},{"location":"api/utilities/#SDMXer.get_parent_id","page":"Utilities","title":"SDMXer.get_parent_id","text":"get_parent_id(code_node::EzXML.Node) -> Union{String, Missing}\n\nExtracts the parent code identifier from an SDMX code node's hierarchical structure.\n\nThis function searches for parent relationships in SDMX codelist hierarchies by examining the <structure:Parent/Ref> XML element and extracting the referenced parent code identifier, enabling hierarchical code analysis and navigation.\n\nArguments\n\ncode_node::EzXML.Node: The SDMX code XML node to examine for parent references\n\nReturns\n\nUnion{String, Missing}: Parent code identifier if found, missing if no parent exists\n\nExamples\n\n# Extract parent ID from hierarchical code\nparent_id = get_parent_id(code_node)\n\nif !ismissing(parent_id)\n    println(\"Code has parent: \", parent_id)\nelse\n    println(\"This is a top-level code\")\nend\n\n# Use in codelist processing\nfor code_node in code_nodes\n    parent = get_parent_id(code_node)\n    code_id = code_node[\"id\"]\n    println(\"Code \", code_id, \" -> Parent: \", parent)\nend\n\nSee also\n\nprocess_code_node\n\n\n\n\n\n","category":"function"},{"location":"api/utilities/#SDMXer.extract_codes_from_codelist_node","page":"Utilities","title":"SDMXer.extract_codes_from_codelist_node","text":"extract_codes_from_codelist_node(cl_node::EzXML.Node) -> Vector{NamedTuple}\n\nExtracts all code data from a single <structure:Codelist> node. It finds the codelist's ID and merges it with the data extracted from each child Code node.\n\nArguments\n\ncl_node::EzXML.Node: The codelist node to process.\n\nReturns\n\nVector{NamedTuple}: A vector of named tuples with code and codelist information.\n\n\n\n\n\n","category":"function"},{"location":"api/utilities/#SDMXer.extract_availability_from_node","page":"Utilities","title":"SDMXer.extract_availability_from_node","text":"extract_availability_from_node(constraint_node::EzXML.Node) -> AvailabilityConstraint\n\nExtracts availability constraint information from a ContentConstraint XML node. This is the core extraction logic used by both extractavailability and extractavailabilityfromdataflow.\n\n\n\n\n\n","category":"function"},{"location":"api/utilities/#SDMXer.extract_dimension_values","page":"Utilities","title":"SDMXer.extract_dimension_values","text":"extract_dimension_values(kv_node::EzXML.Node) -> Vector{String}\n\nExtracts all available values for a dimension from a KeyValue node.\n\n\n\n\n\n","category":"function"},{"location":"api/utilities/#SDMXer.extract_time_availability","page":"Utilities","title":"SDMXer.extract_time_availability","text":"extract_time_availability(time_node::EzXML.Node) -> TimeAvailability\n\nExtracts time coverage information from a TIME_PERIOD KeyValue node.\n\n\n\n\n\n","category":"function"},{"location":"api/units/#Units-and-Conversion","page":"Units & Conversion","title":"Units & Conversion","text":"Unitful integration for SDMX unit codes, currency exchange rates, and unit conversion utilities.","category":"section"},{"location":"api/units/#Types","page":"Units & Conversion","title":"Types","text":"","category":"section"},{"location":"api/units/#Constants","page":"Units & Conversion","title":"Constants","text":"","category":"section"},{"location":"api/units/#Unit-Mapping","page":"Units & Conversion","title":"Unit Mapping","text":"","category":"section"},{"location":"api/units/#Exchange-Rates","page":"Units & Conversion","title":"Exchange Rates","text":"","category":"section"},{"location":"api/units/#SDMXer.SDMXUnitSpec","page":"Units & Conversion","title":"SDMXer.SDMXUnitSpec","text":"SDMXUnitSpec\n\nMaps an SDMX unit code to a Unitful unit with metadata.\n\nFields\n\ncode::String: The SDMX UNIT_MEASURE code (e.g., \"KG\", \"T\", \"USD\")\nunit::Unitful.Units: The corresponding Unitful unit\ncategory::Symbol: Unit category (:mass, :volume, :currency, :energy, :area, :dimensionless, :other)\ndescription::String: Human-readable description\n\n\n\n\n\n","category":"type"},{"location":"api/units/#SDMXer.ExchangeRateTable","page":"Units & Conversion","title":"SDMXer.ExchangeRateTable","text":"ExchangeRateTable\n\nStores exchange rates for cross-currency conversion.\n\nAll rates are stored as domestic currency per 1 USD. Cross-rates are derived automatically. Users can override rates with add_rate!.\n\nFields\n\nrates::Dict{Tuple{String,String}, Float64}: Map from (from, to) currency pair to rate\nreference_date::String: Reference date for the rates\nsource::String: Source description for the rates\n\nExamples\n\ntable = ExchangeRateTable()\nadd_rate!(table, \"USD\", \"FJD\", 2.299)\nadd_rate!(table, \"USD\", \"AUD\", 1.552)\nrate = get_rate(table, \"FJD\", \"AUD\")\n\n\n\n\n\n","category":"type"},{"location":"api/units/#SDMXer.SDMX_UNIT_MAP","page":"Units & Conversion","title":"SDMXer.SDMX_UNIT_MAP","text":"SDMX_UNIT_MAP\n\nMaps ~30 common SDMX UNIT_MEASURE codes to SDMXUnitSpec. Covers SPC Pacific Data Hub codes and common international codes.\n\n\n\n\n\n","category":"constant"},{"location":"api/units/#SDMXer.sdmx_to_unitful","page":"Units & Conversion","title":"SDMXer.sdmx_to_unitful","text":"sdmx_to_unitful(code::AbstractString) -> Union{SDMXUnitSpec, Nothing}\n\nLook up an SDMX UNIT_MEASURE code and return its SDMXUnitSpec, or nothing if unknown.\n\nAccepts any AbstractString subtype (String, String7, SubString, etc.) so it works directly with CSV.jl InlineStrings columns.\n\nExamples\n\nspec = sdmx_to_unitful(\"KG\")\nspec.unit  # kg\nspec.category  # :mass\n\nsdmx_to_unitful(\"UNKNOWN\")  # nothing\n\n\n\n\n\n","category":"function"},{"location":"api/units/#SDMXer.are_units_convertible","page":"Units & Conversion","title":"SDMXer.are_units_convertible","text":"are_units_convertible(code_a::AbstractString, code_b::AbstractString) -> Bool\n\nCheck whether two SDMX unit codes are convertible via Unitful dimensional analysis. Returns false for cross-currency pairs (same dimension but conversion requires rates).\n\nExamples\n\nare_units_convertible(\"KG\", \"T\")   # true  — same mass dimension\nare_units_convertible(\"KG\", \"L\")   # false — mass vs volume\nare_units_convertible(\"USD\", \"EUR\") # false — currencies need exchange rates\n\n\n\n\n\n","category":"function"},{"location":"api/units/#SDMXer.conversion_factor","page":"Units & Conversion","title":"SDMXer.conversion_factor","text":"conversion_factor(from::AbstractString, to::AbstractString) -> Union{Float64, Nothing}\n\nReturn the deterministic conversion factor from one SDMX unit to another. Returns nothing for currencies (use ExchangeRateTable instead) or incompatible units.\n\nExamples\n\nconversion_factor(\"KG\", \"T\")   # 0.001\nconversion_factor(\"T\", \"KG\")   # 1000.0\nconversion_factor(\"USD\", \"EUR\") # nothing — use exchange rates\nconversion_factor(\"KG\", \"L\")   # nothing — incompatible dimensions\n\n\n\n\n\n","category":"function"},{"location":"api/units/#SDMXer.unit_multiplier","page":"Units & Conversion","title":"SDMXer.unit_multiplier","text":"unit_multiplier(mult_code) -> Float64\n\nConvert an SDMX UNIT_MULT code (power-of-10 exponent) to its numeric multiplier.\n\nCommon values: 0 → 1, 3 → 1000, 6 → 1e6, 9 → 1e9\n\nExamples\n\nunit_multiplier(0)    # 1.0\nunit_multiplier(3)    # 1000.0\nunit_multiplier(6)    # 1.0e6\nunit_multiplier(\"3\")  # 1000.0\nunit_multiplier(nothing)  # 1.0\nunit_multiplier(missing)  # 1.0\n\n\n\n\n\n","category":"function"},{"location":"api/units/#SDMXer.add_rate!","page":"Units & Conversion","title":"SDMXer.add_rate!","text":"add_rate!(table::ExchangeRateTable, from::AbstractString, to::AbstractString, rate::Float64)\n\nAdd an exchange rate to the table. Automatically adds the inverse rate.\n\nExamples\n\ntable = ExchangeRateTable()\nadd_rate!(table, \"USD\", \"FJD\", 2.299)\n# Now table has both USD→FJD (2.299) and FJD→USD (1/2.299)\n\n\n\n\n\n","category":"function"},{"location":"api/units/#SDMXer.get_rate","page":"Units & Conversion","title":"SDMXer.get_rate","text":"get_rate(table::ExchangeRateTable, from::AbstractString, to::AbstractString) -> Union{Float64, Nothing}\n\nGet the exchange rate from one currency to another. Tries direct lookup first, then derives cross-rate via USD if both USD-based rates exist.\n\nExamples\n\ntable = default_exchange_rates()\nget_rate(table, \"USD\", \"FJD\")  # 2.299\nget_rate(table, \"FJD\", \"AUD\")  # derived cross-rate\nget_rate(table, \"XXX\", \"YYY\")  # nothing\n\n\n\n\n\n","category":"function"},{"location":"api/units/#SDMXer.convert_currency","page":"Units & Conversion","title":"SDMXer.convert_currency","text":"convert_currency(value::Real, from::AbstractString, to::AbstractString, table::ExchangeRateTable) -> Union{Float64, Nothing}\n\nConvert a monetary value from one currency to another using the exchange rate table. Returns nothing if no rate is available.\n\nExamples\n\ntable = default_exchange_rates()\nconvert_currency(100.0, \"USD\", \"FJD\", table)  # ≈ 229.9\nconvert_currency(100.0, \"FJD\", \"AUD\", table)  # derived via cross-rate\n\n\n\n\n\n","category":"function"},{"location":"api/units/#SDMXer.default_exchange_rates","page":"Units & Conversion","title":"SDMXer.default_exchange_rates","text":"default_exchange_rates() -> ExchangeRateTable\n\nReturn an ExchangeRateTable pre-populated with IMF 2025 annual period-average rates (domestic currency per 1 USD).\n\nThese are approximate default rates intended for quick analysis. For production use, supply your own rates via add_rate! or build a fresh table.\n\nCurrency Per 1 USD Year\nAUD 1.5520 2025\nEUR 0.8850 2025\nFJD 2.2990 2025\nGBP 0.7595 2025\nJPY 149.66 2025\nNZD 1.7201 2025\nPGK 4.1227 2025\nSBD 8.3268 2025\nTOP 2.3730 2024\nVUV 119.17 2024\nWST 2.7915 2025\n\n\n\n\n\n","category":"function"},{"location":"api/availability/#Data-Availability","page":"Availability","title":"Data Availability","text":"Functions for analyzing data availability constraints and temporal coverage.","category":"section"},{"location":"api/availability/#Main-Functions","page":"Availability","title":"Main Functions","text":"","category":"section"},{"location":"api/availability/#Analysis-Functions","page":"Availability","title":"Analysis Functions","text":"","category":"section"},{"location":"api/availability/#Types","page":"Availability","title":"Types","text":"","category":"section"},{"location":"api/availability/#SDMXer.extract_availability","page":"Availability","title":"SDMXer.extract_availability","text":"extract_availability(url::String) -> AvailabilityConstraint\n\nExtracts availability constraint information from an SDMX availability URL.\n\nExample\n\n# For Pacific Data Hub\navailability = extract_availability(\"https://stats-sdmx-disseminate.pacificdata.org/rest/availableconstraint/DF_DISABILITY/\")\n\n\n\n\n\nextract_availability(doc::EzXML.Document) -> AvailabilityConstraint\n\nExtracts availability constraint information from a parsed XML document.\n\n\n\n\n\n","category":"function"},{"location":"api/availability/#SDMXer.extract_availability_from_dataflow","page":"Availability","title":"SDMXer.extract_availability_from_dataflow","text":"extract_availability_from_dataflow(doc::EzXML.Document) -> Union{AvailabilityConstraint, Nothing}\n\nExtracts the Actual type ContentConstraint from a dataflow document's Constraints section. This is used when fetching codelists without a specific filtering key.\n\nReturns nothing if no Actual ContentConstraint is found (which is okay - not all dataflows have it).\n\n\n\n\n\n","category":"function"},{"location":"api/availability/#SDMXer.get_available_values","page":"Availability","title":"SDMXer.get_available_values","text":"get_available_values(availability::AvailabilityConstraint, dimension_id::String) -> Vector{String}\n\nGets available values for a specific dimension.\n\nExample\n\ncountries = get_available_values(availability, \"GEO_PICT\")\nindicators = get_available_values(availability, \"INDICATOR\")\n\n\n\n\n\n","category":"function"},{"location":"api/availability/#SDMXer.get_time_coverage","page":"Availability","title":"SDMXer.get_time_coverage","text":"get_time_coverage(availability::AvailabilityConstraint; frequency_aware::Bool=true) -> Union{TimeAvailability, Nothing}\n\nGets time coverage information if available. When frequency_aware is true, adjusts the  representation based on the FREQ dimension if present, following SDMX time period formats.\n\nSDMX Time Period Formats\n\nA: Annual (YYYY) - e.g., 2010\nS: Semester/half year (YYYY-Sn) - e.g., 2010-S1\nT: Trimester (YYYY-Tn) - e.g., 2010-T1\nQ: Quarterly (YYYY-Qn) - e.g., 2010-Q1\nM: Monthly (YYYY-MM) - e.g., 2010-01\nD: Daily (YYYY-MM-DD) - e.g., 2010-01-01\nH: Hourly (YYYY-MM-DDThh) - e.g., 2010-01-01T13\nI: DateTime (YYYY-MM-DDThh:mm:ss) - e.g., 2010-01-01T20:22:00\n\nArguments\n\navailability: The availability constraint\nfrequency_aware: Whether to adjust representation based on frequency (default: true)\n\nExamples\n\n# For annual data (FREQ=\"A\"), returns years instead of full dates\ntime_coverage = get_time_coverage(availability)\n# TimeAvailability with start_date=1970, end_date=2030, format=\"year\"\n\n# Force date representation regardless of frequency\ntime_coverage = get_time_coverage(availability, frequency_aware=false)\n\n\n\n\n\n","category":"function"},{"location":"api/availability/#SDMXer.compare_schema_availability","page":"Availability","title":"SDMXer.compare_schema_availability","text":"compare_schema_availability(schema::DataflowSchema, availability::AvailabilityConstraint) -> Dict{String, Any}\n\nCompares theoretical schema possibilities with actual data availability.\n\nReturns coverage ratios, missing values, and data gaps analysis.\n\n\n\n\n\n","category":"function"},{"location":"api/availability/#SDMXer.get_data_coverage_summary","page":"Availability","title":"SDMXer.get_data_coverage_summary","text":"get_data_coverage_summary(availability::AvailabilityConstraint) -> DataFrame\n\nCreates a summary DataFrame of data coverage by dimension.\n\n\n\n\n\n","category":"function"},{"location":"api/availability/#SDMXer.find_data_gaps","page":"Availability","title":"SDMXer.find_data_gaps","text":"find_data_gaps(availability::AvailabilityConstraint, expected_values::Dict{String, Vector{String}}) -> Dict{String, Vector{String}}\n\nIdentifies missing values by comparing availability with expected values.\n\nArguments\n\navailability: The availability constraint\nexpected_values: Dict mapping dimension_id to expected value lists\n\nReturns\n\nDict mapping dimension_id to missing values\n\n\n\n\n\n","category":"function"},{"location":"api/availability/#SDMXer.print_availability_summary","page":"Availability","title":"SDMXer.print_availability_summary","text":"print_availability_summary(availability::AvailabilityConstraint)\n\nPrints a human-readable summary of the availability constraint.\n\n\n\n\n\n","category":"function"},{"location":"api/availability/#SDMXer.AvailabilityConstraint","page":"Availability","title":"SDMXer.AvailabilityConstraint","text":"AvailabilityConstraint\n\nComplete availability constraint information from SDMXer.\n\nSee also\n\nextract_availability: extracts this from a dataflow URL or XML\nfilter_codelists_by_availability: filters codelists using availability data\n\n\n\n\n\n","category":"type"},{"location":"api/availability/#SDMXer.DimensionAvailability","page":"Availability","title":"SDMXer.DimensionAvailability","text":"DimensionAvailability\n\nAvailability information for a single dimension.\n\n\n\n\n\n","category":"type"},{"location":"api/availability/#SDMXer.TimeAvailability","page":"Availability","title":"SDMXer.TimeAvailability","text":"TimeAvailability\n\nStructure containing comprehensive information about actual time period coverage in SDMX datasets.\n\nThis struct captures detailed temporal availability information from SDMX availability constraints, including date ranges, format specifications, period counts, and data gaps to provide complete temporal coverage analysis.\n\nFields\n\nstart_date::Union{Date, String}: Earliest available time period in the dataset\nend_date::Union{Date, String}: Latest available time period in the dataset\nformat::String: Time period format (\"date\", \"year\", \"quarter\", \"month\", etc.)\ntotal_periods::Int: Total number of distinct time periods with data\ngaps::Vector{String}: Missing time periods within the overall range\n\nExamples\n\n# Create time availability information\ntime_availability = TimeAvailability(\n    Date(\"2020-01-01\"),\n    Date(\"2023-12-31\"),\n    \"year\", \n    4,\n    [\"2021\"]\n)\n\n# Access coverage information\nprintln(\"Data available from: \", time_availability.start_date)\nprintln(\"Data available to: \", time_availability.end_date)\nprintln(\"Total periods: \", time_availability.total_periods)\n\n# Check for gaps\nif !isempty(time_availability.gaps)\n    println(\"Missing periods: \", join(time_availability.gaps, \", \"))\nend\n\nSee also\n\nAvailabilityConstraint, extract_availability, get_time_coverage\n\n\n\n\n\n","category":"type"},{"location":"api/joins/#Cross-Dataflow-Joins","page":"Cross-Dataflow Joins","title":"Cross-Dataflow Joins","text":"Functions for comparing, harmonizing, and joining SDMX DataFrames across different dataflows.","category":"section"},{"location":"api/joins/#Schema-Comparison","page":"Cross-Dataflow Joins","title":"Schema Comparison","text":"","category":"section"},{"location":"api/joins/#Unit-Conflicts","page":"Cross-Dataflow Joins","title":"Unit Conflicts","text":"","category":"section"},{"location":"api/joins/#Frequency-Alignment","page":"Cross-Dataflow Joins","title":"Frequency Alignment","text":"","category":"section"},{"location":"api/joins/#Horizontal-Join","page":"Cross-Dataflow Joins","title":"Horizontal Join","text":"","category":"section"},{"location":"api/joins/#Vertical-Combine","page":"Cross-Dataflow Joins","title":"Vertical Combine","text":"","category":"section"},{"location":"api/joins/#SDMXer.SchemaComparison","page":"Cross-Dataflow Joins","title":"SDMXer.SchemaComparison","text":"SchemaComparison\n\nResult of comparing two DataflowSchema objects.\n\nFields\n\nschema_a_info::NamedTuple: dataflow_info from schema A\nschema_b_info::NamedTuple: dataflow_info from schema B\nshared_dimensions::DataFrame: Dimensions with the same codelist_id in both schemas\ncompatible_dimensions::DataFrame: Dimensions with different codelist_id but overlapping codes\nunique_to_a::Vector{String}: Dimension IDs only in schema A\nunique_to_b::Vector{String}: Dimension IDs only in schema B\nshared_attributes::Vector{String}: Attribute IDs present in both schemas\ntime_overlap::Union{NamedTuple, Nothing}: Overlapping time range, or nothing\njoinability_score::Float64: Overall joinability score 0.0–1.0\nrecommended_join_dims::Vector{String}: Recommended dimension IDs for joining\n\nSee also\n\ncompare_schemas: produces this result from two DataflowSchema objects\nsdmx_join: uses comparison results to join DataFrames\ndetect_join_columns: uses recommended join dims from comparison\n\n\n\n\n\n","category":"type"},{"location":"api/joins/#SDMXer.CodelistOverlap","page":"Cross-Dataflow Joins","title":"SDMXer.CodelistOverlap","text":"CodelistOverlap\n\nResult of comparing two sets of codelist codes.\n\nFields\n\nintersection::Vector{String}: Codes present in both sets\nonly_in_a::Vector{String}: Codes only in the first set\nonly_in_b::Vector{String}: Codes only in the second set\noverlap_ratio::Float64: |intersection| / |union|, 0.0–1.0\na_coverage::Float64: Fraction of A's codes found in B\nb_coverage::Float64: Fraction of B's codes found in A\n\nSee also\n\ncodelist_overlap: computes this result from two code vectors or DataFrames\ncompare_schemas: uses codelist overlap internally\n\n\n\n\n\n","category":"type"},{"location":"api/joins/#SDMXer.compare_schemas","page":"Cross-Dataflow Joins","title":"SDMXer.compare_schemas","text":"compare_schemas(schema_a::DataflowSchema, schema_b::DataflowSchema) -> SchemaComparison\n\nCompare two DataflowSchema objects to identify shared and compatible dimensions, time overlap, and recommend join dimensions.\n\nShared dimensions have the same codelistid. Compatible dimensions have different codelistids but must be checked for code overlap externally (this function marks them as candidates). The joinability_score reflects how many dimensions overlap.\n\nExamples\n\nschema_a = extract_dataflow_schema(url_a)\nschema_b = extract_dataflow_schema(url_b)\ncomparison = compare_schemas(schema_a, schema_b)\ncomparison.shared_dimensions       # DataFrame of shared dims\ncomparison.recommended_join_dims   # suggested join columns\ncomparison.joinability_score       # 0.0–1.0\n\nSee also\n\nSchemaComparison, DataflowSchema, sdmx_join, detect_join_columns, detect_unit_conflicts\n\n\n\n\n\n","category":"function"},{"location":"api/joins/#SDMXer.codelist_overlap","page":"Cross-Dataflow Joins","title":"SDMXer.codelist_overlap","text":"codelist_overlap(codes_a::Vector{String}, codes_b::Vector{String}) -> CodelistOverlap\n\nCompute set overlap between two vectors of code strings.\n\nExamples\n\noverlap = codelist_overlap([\"FJ\", \"TV\", \"WS\"], [\"FJ\", \"TV\", \"PG\"])\noverlap.intersection  # [\"FJ\", \"TV\"]\noverlap.overlap_ratio # 0.5\n\n\n\n\n\ncodelist_overlap(codelists_df_a::DataFrame, codelists_df_b::DataFrame, id_a::String, id_b::String) -> CodelistOverlap\n\nCompute overlap between two codelists identified by codelist_id within their respective codelists DataFrames.\n\nExpects the standard codelist DataFrame format from extract_all_codelists with columns: codelistid, codeid, lang, name, parentcodeid, order.\n\nExamples\n\ncodelists_a = extract_all_codelists(url_a)\ncodelists_b = extract_all_codelists(url_b)\noverlap = codelist_overlap(codelists_a, codelists_b, \"CL_GEO_PICT\", \"CL_GEO_PICT\")\n\n\n\n\n\n","category":"function"},{"location":"api/joins/#SDMXer.UnitConflict","page":"Cross-Dataflow Joins","title":"SDMXer.UnitConflict","text":"UnitConflict\n\nA single unit conflict between two DataFrames being joined.\n\nFields\n\ndimension::String: The column/dimension where the conflict occurs (\"UNITMEASURE\" or \"UNITMULT\")\nvalue_a::String: Value in the first DataFrame\nvalue_b::String: Value in the second DataFrame\nis_convertible::Bool: Whether automatic conversion is possible\nconversion_factor::Union{Float64, Nothing}: Factor to convert A→B, or nothing\nseverity::Symbol: :none, :warning, or :error\ndescription::String: Human-readable conflict description\n\nSee also\n\nUnitConflictReport: aggregates multiple conflicts\ndetect_unit_conflicts: produces these from two DataFrames\n\n\n\n\n\n","category":"type"},{"location":"api/joins/#SDMXer.UnitConflictReport","page":"Cross-Dataflow Joins","title":"SDMXer.UnitConflictReport","text":"UnitConflictReport\n\nSummary of all unit conflicts between two DataFrames.\n\nFields\n\nconflicts::Vector{UnitConflict}: All detected conflicts\nunit_measure_conflicts::Vector{UnitConflict}: UNIT_MEASURE-specific conflicts\nunit_mult_conflicts::Vector{UnitConflict}: UNIT_MULT-specific conflicts\ncurrency_conflicts::Vector{UnitConflict}: Currency-related conflicts\nhas_blocking_conflicts::Bool: True if any conflict has :error severity\nauto_resolvable_count::Int: Number of conflicts that can be automatically resolved\nsummary::String: Human-readable summary\n\nSee also\n\ndetect_unit_conflicts: produces this report\nharmonize_units: resolves convertible conflicts\nsdmx_join: uses this report during join validation\n\n\n\n\n\n","category":"type"},{"location":"api/joins/#SDMXer.detect_unit_conflicts","page":"Cross-Dataflow Joins","title":"SDMXer.detect_unit_conflicts","text":"detect_unit_conflicts(df_a::DataFrame, df_b::DataFrame;\n                     join_dims::Vector{String}=String[],\n                     exchange_rates::Union{ExchangeRateTable, Nothing}=nothing) -> UnitConflictReport\n\nCompare UNITMEASURE and UNITMULT columns between two DataFrames and report conflicts.\n\nWhen join_dims is provided, only compares unit pairs that would actually appear together in joined rows (grouped comparison). This avoids false positives from cross-dimensional pairs (e.g., FJD from a monetary indicator vs NUM from a count indicator in the same dataset).\n\nWhen join_dims is empty, falls back to comparing all unique unit values (all-vs-all), which may produce false positives for multi-indicator datasets.\n\nExamples\n\n# Grouped comparison — only flags conflicts for rows that will be joined\nreport = detect_unit_conflicts(trade_df, gdp_df; join_dims=[\"GEO_PICT\", \"TIME_PERIOD\"])\n\n# All-vs-all fallback\nreport = detect_unit_conflicts(trade_df, gdp_df)\n\nSee also\n\nUnitConflictReport, harmonize_units, sdmx_join\n\n\n\n\n\n","category":"function"},{"location":"api/joins/#SDMXer.normalize_units!","page":"Cross-Dataflow Joins","title":"SDMXer.normalize_units!","text":"normalize_units!(df::DataFrame;\n                target_unit::Union{String, Nothing}=nothing,\n                exchange_rates::Union{ExchangeRateTable, Nothing}=nothing) -> DataFrame\n\nNormalize a DataFrame's OBSVALUE by applying UNITMULT and optionally converting UNIT_MEASURE.\n\nOperations (in order):\n\nIf UNITMULT column exists, multiply OBSVALUE by 10^UNITMULT, then set UNITMULT to 0\nIf targetunit is specified and UNITMEASURE exists, convert values to target_unit\n\nMutates df in place and returns it.\n\nExamples\n\n# Normalize UNIT_MULT only\nnormalize_units!(df)\n\n# Normalize and convert to tonnes\nnormalize_units!(df; target_unit=\"T\")\n\n# Normalize with currency conversion\nnormalize_units!(df; target_unit=\"USD\", exchange_rates=default_exchange_rates())\n\n\n\n\n\n","category":"function"},{"location":"api/joins/#SDMXer.harmonize_units","page":"Cross-Dataflow Joins","title":"SDMXer.harmonize_units","text":"harmonize_units(df_a::DataFrame, df_b::DataFrame;\n               target_unit::Union{String, Nothing}=nothing,\n               exchange_rates::Union{ExchangeRateTable, Nothing}=nothing) -> Tuple{DataFrame, DataFrame}\n\nNon-mutating version: copies both DataFrames then normalizes them.\n\nReturns (normalized_a, normalized_b).\n\nExamples\n\nnorm_a, norm_b = harmonize_units(trade_df, gdp_df; target_unit=\"USD\",\n                                  exchange_rates=default_exchange_rates())\n\nSee also\n\ndetect_unit_conflicts, normalize_units!, sdmx_join\n\n\n\n\n\n","category":"function"},{"location":"api/joins/#SDMXer.FrequencyAlignment","page":"Cross-Dataflow Joins","title":"SDMXer.FrequencyAlignment","text":"FrequencyAlignment\n\nDescribes the frequency alignment applied to a pair of DataFrames.\n\nFields\n\nsource_freq::String: Original frequency of the higher-freq DataFrame (e.g., \"Q\", \"M\")\ntarget_freq::String: Target frequency after alignment (e.g., \"A\")\nmethod::Symbol: Alignment method used (:aggregate, :none, :passthrough)\naggregation_fn::Symbol: Aggregation function used (:sum, :mean, :last, :first, :max, :min)\n\nSee also\n\nalign_frequencies: produces this result when aligning two DataFrames\n\n\n\n\n\n","category":"type"},{"location":"api/joins/#SDMXer.align_frequencies","page":"Cross-Dataflow Joins","title":"SDMXer.align_frequencies","text":"align_frequencies(df_a::DataFrame, df_b::DataFrame;\n                 time_col::String=\"TIME_PERIOD\",\n                 freq_col::String=\"FREQ\",\n                 value_col::String=\"OBS_VALUE\",\n                 target_freq::Union{String, Nothing}=nothing,\n                 aggregation::Symbol=:sum,\n                 group_cols::Union{Vector{String}, Nothing}=nothing) -> Tuple{DataFrame, DataFrame, FrequencyAlignment}\n\nAlign two DataFrames to a common time frequency by aggregating higher-frequency data.\n\nIf target_freq is not specified, uses the lower frequency of the two (e.g., if one is quarterly and the other annual, aggregates the quarterly data to annual).\n\nArguments\n\ndf_a, df_b: DataFrames to align\ntime_col: Name of the time period column (default \"TIME_PERIOD\")\nfreq_col: Name of the frequency column (default \"FREQ\")\nvalue_col: Name of the observation value column (default \"OBS_VALUE\")\ntarget_freq: Force alignment to this frequency (default: auto-detect)\naggregation: Aggregation function (:sum, :mean, :last, :first, :max, :min)\ngroup_cols: Additional columns to group by during aggregation (auto-detected if nothing)\n\nReturns\n\n(aligned_a, aligned_b, alignment_info): Aligned DataFrames and alignment metadata\n\nExamples\n\naligned_a, aligned_b, info = align_frequencies(quarterly_df, annual_df)\ninfo.source_freq   # \"Q\"\ninfo.target_freq   # \"A\"\ninfo.method        # :aggregate\n\n\n\n\n\n","category":"function"},{"location":"api/joins/#SDMXer.JoinResult","page":"Cross-Dataflow Joins","title":"SDMXer.JoinResult","text":"JoinResult\n\nResult of joining two SDMX DataFrames.\n\nFields\n\ndata::DataFrame: The joined DataFrame\njoin_columns::Vector{String}: Columns used for the join\njoin_type::Symbol: Type of join performed (:inner, :outer, :left, :right)\nrows_matched::Int: Number of rows in the result\nunit_report::Union{UnitConflictReport, Nothing}: Unit conflict analysis\nwarnings::Vector{String}: Any warnings generated during the join\nmetadata::Dict{String, Any}: Additional metadata about the join\n\nSee also\n\nsdmx_join: produces this result\n\n\n\n\n\n","category":"type"},{"location":"api/joins/#SDMXer.detect_join_columns","page":"Cross-Dataflow Joins","title":"SDMXer.detect_join_columns","text":"detect_join_columns(df_a::DataFrame, df_b::DataFrame;\n                   schema_a::Union{DataflowSchema, Nothing}=nothing,\n                   schema_b::Union{DataflowSchema, Nothing}=nothing) -> Vector{String}\n\nDetect appropriate columns for joining two SDMX DataFrames.\n\nPriority:\n\nIf schemas provided, prefer columns with matching codelist_ids\nOtherwise, find columns present in both DataFrames\nExclude SDMX metadata columns (OBSVALUE, UNITMEASURE, etc.)\nValidate that candidate columns have overlapping values\n\nExamples\n\njoin_cols = detect_join_columns(trade_df, pop_df)\njoin_cols = detect_join_columns(trade_df, pop_df; schema_a=schema_trade, schema_b=schema_pop)\n\nSee also\n\nsdmx_join, compare_schemas\n\n\n\n\n\n","category":"function"},{"location":"api/joins/#SDMXer.sdmx_join","page":"Cross-Dataflow Joins","title":"SDMXer.sdmx_join","text":"sdmx_join(df_a::DataFrame, df_b::DataFrame;\n         on::Union{Symbol, Vector{String}}=:auto,\n         join_type::Symbol=:inner,\n         validate_units::Bool=true,\n         harmonize::Bool=true,\n         exchange_rates::Union{ExchangeRateTable, Nothing}=nothing,\n         schema_a::Union{DataflowSchema, Nothing}=nothing,\n         schema_b::Union{DataflowSchema, Nothing}=nothing,\n         suffix_a::String=\"_a\",\n         suffix_b::String=\"_b\") -> JoinResult\n\nJoin two SDMX DataFrames with unit validation, harmonization, and automatic join column detection.\n\nArguments\n\ndf_a, df_b: DataFrames to join\non: Join columns. :auto to auto-detect, or explicit column names.\njoin_type: :inner, :outer, :left, or :right\nvalidate_units: Check for unit conflicts before joining\nharmonize: Normalize UNITMULT into OBSVALUE before joining\nexchange_rates: Exchange rate table for currency conversion\nschema_a, schema_b: Optional schemas for smarter column detection\nsuffix_a, suffix_b: Suffixes for conflicting column names (e.g., OBSVALUEa)\n\nReturns\n\nJoinResult: Contains the joined DataFrame, join metadata, and any warnings\n\nExamples\n\nresult = sdmx_join(trade_df, pop_df; join_type=:inner)\nresult.data              # joined DataFrame\nresult.join_columns      # columns used\nresult.warnings          # any issues\n\n# With explicit columns and exchange rates\nresult = sdmx_join(trade_df, gdp_df;\n    on=[\"GEO_PICT\", \"TIME_PERIOD\"],\n    exchange_rates=default_exchange_rates())\n\nSee also\n\nJoinResult, compare_schemas, detect_unit_conflicts, harmonize_units, detect_join_columns, sdmx_combine\n\n\n\n\n\n","category":"function"},{"location":"api/joins/#SDMXer.CombineResult","page":"Cross-Dataflow Joins","title":"SDMXer.CombineResult","text":"CombineResult\n\nResult of vertically combining (stacking) SDMX DataFrames.\n\nFields\n\ndata::DataFrame: The stacked DataFrame\nsource_col::String: Name of the provenance column\nsources::Vector{String}: Labels for each source DataFrame\nunit_reports::Vector{UnitConflictReport}: Unit conflict reports (one per pair; empty if validation skipped)\nwarnings::Vector{String}: Any warnings generated during combining\nmetadata::Dict{String, Any}: Additional metadata\n\nSee also\n\nsdmx_combine: produces this result\npivot_sdmx_wide: reshapes combined data from long to wide format\n\n\n\n\n\n","category":"type"},{"location":"api/joins/#SDMXer.sdmx_combine","page":"Cross-Dataflow Joins","title":"SDMXer.sdmx_combine","text":"sdmx_combine(df_a::DataFrame, df_b::DataFrame;\n    source_col=\"DATAFLOW\", source_a=\"A\", source_b=\"B\",\n    harmonize=true, validate_units=true) -> CombineResult\n\nVertically stack two SDMX DataFrames in tidy long format.\n\nEach row remains one observation. A provenance column (source_col) tracks which dataflow each row came from. Columns present in one DataFrame but not the other are filled with missing.\n\nUse sdmx_combine instead of sdmx_join when both DataFrames have indicator/commodity columns that would produce a cartesian explosion in a horizontal join. After combining, use pivot_sdmx_wide to reshape as needed.\n\nArguments\n\ndf_a, df_b: DataFrames to stack\nsource_col: Name of the provenance column (default \"DATAFLOW\")\nsource_a, source_b: Labels for each source (default \"A\", \"B\")\nharmonize: Normalize UNITMULT into OBSVALUE before stacking (default true)\nvalidate_units: Run unit conflict detection for informational warnings (default true)\n\nExamples\n\nresult = sdmx_combine(trade_df, pop_df; source_a=\"Trade\", source_b=\"Population\")\nresult.data              # stacked DataFrame\nresult.sources           # [\"Trade\", \"Population\"]\nresult.warnings          # informational unit warnings\n\nSee also\n\nCombineResult, pivot_sdmx_wide, sdmx_join\n\n\n\n\n\nsdmx_combine(df_a::DataFrame, df_b::DataFrame,\n    exchange_rates::ExchangeRateTable; kwargs...) -> CombineResult\n\nVertically stack two SDMX DataFrames with exchange rate conversion.\n\nSee the no-exchange-rates method for full documentation.\n\n\n\n\n\nsdmx_combine(dfs::Vector{DataFrame};\n    source_col=\"DATAFLOW\", sources=String[],\n    harmonize=true, validate_units=true) -> CombineResult\n\nVertically stack multiple SDMX DataFrames in tidy long format.\n\nReduces pairwise from left to right. If sources is empty, auto-generates labels \"DF_1\", \"DF_2\", etc.\n\nExamples\n\nresult = sdmx_combine([trade_df, pop_df, gdp_df];\n    sources=[\"Trade\", \"Population\", \"GDP\"])\n\n\n\n\n\nsdmx_combine(dfs::Vector{DataFrame},\n    exchange_rates::ExchangeRateTable; kwargs...) -> CombineResult\n\nVertically stack multiple SDMX DataFrames with exchange rate conversion.\n\nSee the no-exchange-rates method for full documentation.\n\n\n\n\n\n","category":"function"},{"location":"api/joins/#SDMXer.pivot_sdmx_wide","page":"Cross-Dataflow Joins","title":"SDMXer.pivot_sdmx_wide","text":"pivot_sdmx_wide(df::DataFrame;\n    indicator_col::Union{String, Symbol},\n    value_col::Union{String, Symbol}=:OBS_VALUE) -> DataFrame\n\nPivot a tidy (long) SDMX DataFrame to wide format.\n\nThin wrapper around DataFrames.unstack. Useful after sdmx_combine when you want each indicator as its own column.\n\nArguments\n\nindicator_col: Column whose unique values become new column names\nvalue_col: Column containing values to spread (default :OBS_VALUE)\n\nExamples\n\ncombined = sdmx_combine(trade_df, pop_df)\nwide = pivot_sdmx_wide(combined.data; indicator_col=:INDICATOR)\n\nSee also\n\nsdmx_combine, CombineResult\n\n\n\n\n\n","category":"function"},{"location":"getting_started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"getting_started/#Installation","page":"Getting Started","title":"Installation","text":"Install SDMXer.jl from the Julia package registry:\n\nusing Pkg\nPkg.add(\"SDMXer\")","category":"section"},{"location":"getting_started/#Basic-Workflow","page":"Getting Started","title":"Basic Workflow","text":"","category":"section"},{"location":"getting_started/#1.-Extract-SDMX-Schema","page":"Getting Started","title":"1. Extract SDMX Schema","text":"The first step is to extract the dataflow schema from an SDMX-ML document or API endpoint:\n\nusing SDMXer\n\nurl = \"https://stats-sdmx-disseminate.pacificdata.org/rest/dataflow/SPC/DF_BP50/latest?references=all\"\nschema = extract_dataflow_schema(url)\n\n# Inspect the schema\nprintln(\"Dimensions: \", length(schema.dimensions))\nprintln(\"Measures: \", length(schema.measures))\nprintln(\"Attributes: \", length(schema.attributes))","category":"section"},{"location":"getting_started/#2.-Extract-Codelists","page":"Getting Started","title":"2. Extract Codelists","text":"Extract codelists that define valid values for dimensions:\n\n# Get all codelists\nall_codelists = extract_all_codelists(url, false)\n\n# Or get only codelists filtered by availability\navailable_codelists = extract_all_codelists(url, true)\n\n# Access specific codelist\ngeo_codes = available_codelists[available_codelists.codelist_id .== \"CL_GEO_PICT\", :]","category":"section"},{"location":"getting_started/#3.-Analyze-Data-Availability","page":"Getting Started","title":"3. Analyze Data Availability","text":"Understand what data is available:\n\navailability = extract_availability_from_dataflow(url)\n\n# Get available values for a dimension\ncountry_values = get_available_values(availability, \"GEO_PICT\")\n\n# Get time coverage\ntime_range = get_time_coverage(availability)","category":"section"},{"location":"getting_started/#4.-Validate-Data","page":"Getting Started","title":"4. Validate Data","text":"Validate your data against the SDMX schema:\n\nusing CSV, DataFrames\n\n# Create validator\nvalidator = create_validator(schema, available_codelists)\n\n# Validate CSV file\nresult = validate_sdmx_csv(validator, \"my_data.csv\")\n\n# Check results\nif result.is_valid\n    println(\"Data is valid!\")\nelse\n    println(\"Validation errors:\")\n    for error in result.errors\n        println(\"  \", error.message)\n    end\nend","category":"section"},{"location":"getting_started/#5.-Query-Data","page":"Getting Started","title":"5. Query Data","text":"Construct and execute SDMX API queries:\n\n# Build a data query\ndata_url = construct_data_url(\n    \"https://stats-sdmx-disseminate.pacificdata.org\",\n    \"SPC\", \"DF_BP50\",\n    dimensions = Dict(\"GEO_PICT\" => \"FJ\", \"INDICATOR\" => \"BP_CA_P6_BAL_BP6\")\n)\n\n# Fetch data\ndata = fetch_sdmx_data(data_url)","category":"section"},{"location":"getting_started/#Using-Pipelines","page":"Getting Started","title":"Using Pipelines","text":"SDMXer.jl supports functional pipeline operations:\n\n# Chain operations\nresult = schema |>\n    s -> create_validator(s, codelists) |>\n    v -> validate_sdmx_csv(v, \"data.csv\")\n\n# Or use the pipe operator\nusing SDMXer: ⇒\n\nschema ⇒ validate_with(codelists, \"data.csv\")","category":"section"},{"location":"getting_started/#Next-Steps","page":"Getting Started","title":"Next Steps","text":"Explore the API Reference for detailed function documentation\nCheck out Examples for more use cases\nFor LLM-powered data transformation, see SDMXerWizard.jl","category":"section"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/#Complete-Workflow-Example","page":"Examples","title":"Complete Workflow Example","text":"This example demonstrates a complete workflow from schema extraction to data validation:\n\nusing SDMXer, CSV, DataFrames\n\n# Define SDMX API endpoint\nurl = \"https://stats-sdmx-disseminate.pacificdata.org/rest/dataflow/SPC/DF_BP50/latest?references=all\"\n\n# 1. Extract schema\nschema = extract_dataflow_schema(url)\n\n# 2. Get codelists with availability filtering\ncodelists = extract_all_codelists(url, true)\n\n# 3. Get data availability\navailability = extract_availability_from_dataflow(url)\nprintln(\"Available countries: \", join(get_available_values(availability, \"GEO_PICT\"), \", \"))\n\n# 4. Load your data\nmy_data = CSV.read(\"my_data.csv\", DataFrame)\n\n# 5. Create validator\nvalidator = create_validator(schema, codelists)\n\n# 6. Validate\nresult = validate_sdmx_csv(validator, \"my_data.csv\")\n\n# 7. Generate report\nreport = generate_validation_report(result)\nprintln(report)","category":"section"},{"location":"examples/#Working-with-Pacific-Data-Hub","page":"Examples","title":"Working with Pacific Data Hub","text":"Example using the Pacific Data Hub SDMX API:\n\nusing SDMXer\n\n# Balance of Payments dataflow\nbp_url = \"https://stats-sdmx-disseminate.pacificdata.org/rest/dataflow/SPC/DF_BP50/latest?references=all\"\nbp_schema = extract_dataflow_schema(bp_url)\n\n# Query specific data\nquery_url = construct_data_url(\n    \"https://stats-sdmx-disseminate.pacificdata.org\",\n    \"SPC\", \"DF_BP50\",\n    dimensions = Dict(\n        \"GEO_PICT\" => \"FJ+TV\",  # Fiji and Tuvalu\n        \"FREQ\" => \"A\"            # Annual frequency\n    ),\n    start_period = \"2020\",\n    end_period = \"2023\"\n)\n\ndata = fetch_sdmx_data(query_url)","category":"section"},{"location":"examples/#Codelist-Analysis","page":"Examples","title":"Codelist Analysis","text":"Working with hierarchical codelists:\n\nusing SDMXer\n\nurl = \"https://stats-sdmx-disseminate.pacificdata.org/rest/dataflow/SPC/DF_BP50/latest?references=all\"\n\n# Get all codelists\ncodelists = extract_all_codelists(url, false)\n\n# Find specific codelist\ngeo_codelist = codelists[codelists.codelist_id .== \"CL_GEO_PICT\", :]\n\n# Examine hierarchical structure\nfor row in eachrow(geo_codelist)\n    indent = row.parent_id === missing ? \"\" : \"  \"\n    println(indent, row.code_id, \" - \", row.name)\nend","category":"section"},{"location":"examples/#Validation-with-Custom-Rules","page":"Examples","title":"Validation with Custom Rules","text":"Create a validator with custom validation rules:\n\nusing SDMXer\n\nschema = extract_dataflow_schema(url)\ncodelists = extract_all_codelists(url, true)\n\n# Create validator\nvalidator = create_validator(schema, codelists)\n\n# Validate with preview\nresult = validate_sdmx_csv(validator, \"data.csv\")\n\n# Preview the output\npreview = preview_validation_output(result; max_rows=10)\nprintln(preview)","category":"section"},{"location":"examples/#Pipeline-Operations","page":"Examples","title":"Pipeline Operations","text":"Using functional pipeline style:\n\nusing SDMXer\n\n# Define a validation pipeline\nvalidation_pipeline = pipeline(\n    extract_dataflow_schema,\n    s -> (s, extract_all_codelists(url, true)),\n    ((s, c),) -> create_validator(s, c),\n    v -> validate_sdmx_csv(v, \"data.csv\")\n)\n\n# Execute pipeline\nresult = validation_pipeline(url)","category":"section"},{"location":"examples/#Data-Coverage-Analysis","page":"Examples","title":"Data Coverage Analysis","text":"Analyze temporal and dimensional coverage:\n\nusing SDMXer\n\nurl = \"https://stats-sdmx-disseminate.pacificdata.org/rest/dataflow/SPC/DF_BP50/latest?references=all\"\n\n# Get availability\navailability = extract_availability_from_dataflow(url)\n\n# Get coverage summary\nsummary = get_data_coverage_summary(availability, schema)\nprintln(\"Data coverage: \", summary[\"coverage_percentage\"], \"%\")\n\n# Find gaps\ngaps = find_data_gaps(availability, schema)\nif !isempty(gaps)\n    println(\"Data gaps found in: \", join(gaps, \", \"))\nend","category":"section"},{"location":"examples/#Querying-Multiple-Series","page":"Examples","title":"Querying Multiple Series","text":"Query multiple data series at once:\n\nusing SDMXer, DataFrames\n\n# Define multiple queries\nqueries = [\n    Dict(\"GEO_PICT\" => \"FJ\", \"INDICATOR\" => \"BP_CA_P6_BAL_BP6\"),\n    Dict(\"GEO_PICT\" => \"TV\", \"INDICATOR\" => \"BP_CA_P6_BAL_BP6\"),\n    Dict(\"GEO_PICT\" => \"VU\", \"INDICATOR\" => \"BP_CA_P6_BAL_BP6\")\n]\n\n# Fetch all\nall_data = DataFrame()\nfor q in queries\n    url = construct_data_url(\n        \"https://stats-sdmx-disseminate.pacificdata.org\",\n        \"SPC\", \"DF_BP50\",\n        dimensions = q\n    )\n    data = fetch_sdmx_data(url)\n    append!(all_data, data)\nend","category":"section"},{"location":"api/queries/#Data-Queries","page":"Data Queries","title":"Data Queries","text":"Functions for constructing and executing SDMX REST API queries.","category":"section"},{"location":"api/queries/#Main-Functions","page":"Data Queries","title":"Main Functions","text":"","category":"section"},{"location":"api/queries/#Utilities","page":"Data Queries","title":"Utilities","text":"","category":"section"},{"location":"api/queries/#SDMXer.construct_data_url","page":"Data Queries","title":"SDMXer.construct_data_url","text":"construct_data_url(base_url::String, agency_id::String, dataflow_id::String, version::String; kwargs...) -> String\n\nConstructs SDMX data query URLs with flexible filtering options.\n\nThis function builds complete SDMX REST API data query URLs according to the SDMX 2.1 standard, supporting various filtering approaches including pre-built keys, schema-based dimension filtering, and time period constraints.\n\nArguments\n\nbase_url::String: SDMX REST API base URL  \nagency_id::String: Data provider agency (e.g., \"SPC\", \"ECB\", \"OECD\")\ndataflow_id::String: Dataflow identifier (e.g., \"DF_BP50\", \"EXR\", \"QNA\")\nversion::String: Dataflow version (e.g., \"1.0\" or \"latest\")\nschema::Union{DataflowSchema,Nothing}=nothing: Optional schema for key construction\nkey::String=\"\": Pre-constructed key string (overrides dimension_filters)\ndimension_filters::Dict{String,String}=Dict{String,String}(): Dimension name-value pairs\nstart_period::Union{String,Nothing}=nothing: Start date/period for time filtering\nend_period::Union{String,Nothing}=nothing: End date/period for time filtering\ndimension_at_observation::String=\"AllDimensions\": Response structure format\n\nReturns\n\nString: Complete SDMX REST API data query URL\n\nExamples\n\n# Using pre-constructed key (most flexible)\nurl = construct_data_url(\n    \"https://stats-sdmx-disseminate.pacificdata.org/rest\",\n    \"SPC\", \"DF_BP50\", \"1.0\",\n    key=\"A.TO.BX_TRF_PWKR._T._T._T._T._T._T._T....\",\n    start_period=\"2022\"\n)\n\n# Using dimension filters with schema validation\nurl = construct_data_url(\n    \"https://sdw-wsrest.ecb.europa.eu/service\",\n    \"ECB\", \"EXR\", \"1.0\", \n    schema=schema,\n    dimension_filters=Dict(\"FREQ\" => \"D\", \"CURRENCY\" => \"USD\"),\n    start_period=\"2023-01\"\n)\n\n# Simple case - get all data with time filtering\nurl = construct_data_url(\n    \"https://stats-sdmx-disseminate.pacificdata.org/rest\",\n    \"SPC\", \"DF_BP50\", \"1.0\",\n    start_period=\"2022\"\n)\n\nSee also\n\nconstruct_sdmx_key, fetch_sdmx_data, query_sdmx_data\n\n\n\n\n\n","category":"function"},{"location":"api/queries/#SDMXer.fetch_sdmx_data","page":"Data Queries","title":"SDMXer.fetch_sdmx_data","text":"fetch_sdmx_data(url::String; timeout::Int=30) -> DataFrame\n\nFetches and parses SDMX data in CSV format from REST API endpoints.\n\nThis function retrieves SDMX data using the standard SDMX-CSV format, performs basic data cleaning and type conversion, and returns a structured DataFrame suitable for analysis. Works with any SDMX 2.1 compliant provider.\n\nArguments\n\nurl::String: Complete SDMX REST API data query URL\ntimeout::Int=30: HTTP timeout in seconds\n\nReturns\n\nDataFrame: Cleaned dataset with appropriate column types\n\nExamples\n\n# Pacific Data Hub\nurl = construct_data_url(\"https://stats-sdmx-disseminate.pacificdata.org/rest\", \n                        \"SPC\", \"DF_BP50\", \"1.0\", start_period=\"2022\")\ndata = fetch_sdmx_data(url)\n\n# ECB exchange rates with custom timeout\nurl = construct_data_url(\"https://sdw-wsrest.ecb.europa.eu/service\",\n                        \"ECB\", \"EXR\", \"1.0\", \n                        dimension_filters=Dict(\"FREQ\" => \"D\", \"CURRENCY\" => \"USD\"))\ndata = fetch_sdmx_data(url; timeout=60)\n\n# Handle empty responses gracefully\ndata = fetch_sdmx_data(url)\nif nrow(data) == 0\n    println(\"No data available for query\")\nend\n\nThrows\n\nArgumentError: For HTTP errors, invalid responses, or network issues\n\nSee also\n\nconstruct_data_url, clean_sdmx_data, query_sdmx_data\n\n\n\n\n\n","category":"function"},{"location":"api/queries/#SDMXer.query_sdmx_data","page":"Data Queries","title":"SDMXer.query_sdmx_data","text":"query_sdmx_data(base_url::String, agency_id::String, dataflow_id::String, version::String=\"latest\"; kwargs...) -> DataFrame\n\nConvenience function for complete SDMX data retrieval in a single call.\n\nThis high-level function combines URL construction and data fetching into a single operation, providing the most convenient way to retrieve SDMX data from any provider. It handles URL building, HTTP requests, and data cleaning automatically.\n\nArguments\n\nbase_url::String: SDMX REST API base URL\nagency_id::String: Data provider agency identifier\ndataflow_id::String: Dataflow identifier\nversion::String=\"latest\": Dataflow version\nkey::String=\"\": Pre-constructed SDMX key\nfilters::Dict{String,<:Any}: Combined filters including dimensions and TIME_PERIOD\nDimension values can be String or Vector{String} for multiple values\nTIME_PERIOD can be a single value, array, or range format \"start:end\"\ndimension_filters::Dict{String,<:Any}: Dimension filters (deprecated, use filters)\nstart_period::Union{String,Nothing}=nothing: Start date/period filter\nend_period::Union{String,Nothing}=nothing: End date/period filter\n\nReturns\n\nDataFrame: Cleaned SDMX data ready for analysis\n\nExamples\n\n# Pacific Data Hub - multiple countries with time range\ndata = query_sdmx_data(\n    \"https://stats-sdmx-disseminate.pacificdata.org/rest\",\n    \"SPC\", \"DF_BP50\",\n    filters=Dict(\"GEO_PICT\" => [\"FJ\", \"VU\"], \"TIME_PERIOD\" => \"2020:2023\")\n)\n\n# Single country, specific year\ndata = query_sdmx_data(\n    \"https://stats-sdmx-disseminate.pacificdata.org/rest\",\n    \"SPC\", \"DF_BP50\",\n    filters=Dict(\"GEO_PICT\" => \"TO\", \"TIME_PERIOD\" => \"2022\")\n)\n\n# ECB - EUR/USD daily exchange rates\ndata = query_sdmx_data(\n    \"https://sdw-wsrest.ecb.europa.eu/service\",\n    \"ECB\", \"EXR\", \"1.0\",\n    filters=Dict(\"FREQ\" => \"D\", \"CURRENCY\" => \"USD\", \"CURRENCY_DENOM\" => \"EUR\"),\n    start_period=\"2024-01-01\"\n)\n\n# OECD - using pre-constructed key\ndata = query_sdmx_data(\n    \"https://stats.oecd.org/restsdmx/sdmx.ashx\",\n    \"OECD\", \"QNA\", \"1.0\",\n    key=\"AUS.GDP.CPC.Y.L\",  # Australia, GDP, Current prices, Yearly, Levels\n    start_period=\"2020\"\n)\n\n# Handle potential empty results\ndata = query_sdmx_data(base_url, agency, dataflow, version)\nprintln(\"Retrieved \", nrow(data), \" observations\")\n\nSee also\n\nconstruct_data_url, fetch_sdmx_data, summarize_data, validate_sdmx_csv\n\n\n\n\n\n","category":"function"},{"location":"api/queries/#SDMXer.construct_sdmx_key","page":"Data Queries","title":"SDMXer.construct_sdmx_key","text":"construct_sdmx_key(schema::DataflowSchema, filters::Dict{String,String}) -> String\n\nConstructs a proper SDMX key using dataflow schema dimension ordering.\n\nThis function builds an SDMX data key by ordering dimensions according to the schema definition and validates that all filter dimensions exist in the schema. The resulting key follows SDMX standards with dot-separated dimension values.\n\nArguments\n\nschema::DataflowSchema: DataflowSchema containing dimension definitions and order\nfilters::Dict{String,String}: Dict mapping dimension names to filter values\n\nReturns\n\nString: Properly formatted SDMX key with dimensions in correct order\n\nExamples\n\n# Get schema first\nxml_doc = read_sdmx_structure(url)\nschema = extract_dataflow_schema(xml_doc)\n\n# Construct key with validation\nfilters = Dict(\"FREQ\" => \"A\", \"GEO_PICT\" => \"TO\")\nkey = construct_sdmx_key(schema, filters)\n# Returns: \"A.TO...\" (proper SDMX key based on schema dimension order)\n\nThrows\n\nArgumentError: If any filter dimension is not found in the schema\n\nSee also\n\nconstruct_data_url, get_dimension_order\n\n\n\n\n\nconstruct_sdmx_key(schema::DataflowSchema, filters::Dict{String,<:Any}) -> String\n\nConstructs a proper SDMX key with support for multiple values per dimension.\n\nThis method handles filters with array values, automatically converting them to SDMX '+' notation for multiple selections.\n\nArguments\n\nschema::DataflowSchema: DataflowSchema containing dimension definitions and order\nfilters::Dict{String,<:Any}: Dict with String or Vector{String} values\n\nExamples\n\n# With multiple values\nfilters = Dict(\"GEO_PICT\" => [\"FJ\", \"VU\"], \"FREQ\" => \"A\")\nkey = construct_sdmx_key(schema, filters)\n# Returns: \"A..FJ+VU...\" (with '+' for multiple values)\n\n\n\n\n\n","category":"function"},{"location":"api/queries/#SDMXer.clean_sdmx_data","page":"Data Queries","title":"SDMXer.clean_sdmx_data","text":"clean_sdmx_data(data::DataFrame) -> DataFrame\n\nPerforms standardized cleaning and type conversion on SDMX-CSV data.\n\nThis function applies standard SDMX data cleaning procedures including numeric conversion of observation values, string formatting of time periods, and removal of empty rows. Works with CSV output from any SDMX 2.1 compliant provider.\n\nArguments\n\ndata::DataFrame: Raw DataFrame from SDMX-CSV parsing\n\nReturns\n\nDataFrame: Cleaned DataFrame with standardized column types\n\nExamples\n\n# Manual cleaning after CSV import\nraw_data = CSV.read(\"sdmx_data.csv\", DataFrame)\ncleaned_data = clean_sdmx_data(raw_data)\n\n# Automatic cleaning within fetch_sdmx_data\ndata = fetch_sdmx_data(url)  # Cleaning applied automatically\n\nSee also\n\nfetch_sdmx_data\n\n\n\n\n\n","category":"function"},{"location":"api/queries/#SDMXer.summarize_data","page":"Data Queries","title":"SDMXer.summarize_data","text":"summarize_data(data::DataFrame) -> Dict{String, Any}\n\nProvides comprehensive statistical summary of SDMX datasets.\n\nThis function generates a summary report containing key statistics about an SDMX dataset including observation counts, time range coverage, value statistics, and dimension value distributions. Works with data from any SDMX provider.\n\nArguments\n\ndata::DataFrame: SDMX dataset to summarize\n\nReturns\n\nDict{String, Any}: Summary statistics including observation counts, time ranges, and dimension values\n\nExamples\n\ndata = query_sdmx_data(base_url, \"SPC\", \"DF_BP50\", \"1.0\")\nsummary = summarize_data(data)\n\nprintln(\"Total observations: \", summary[\"total_observations\"])\nprintln(\"Time range: \", summary[\"time_range\"])\nif haskey(summary, \"obs_stats\")\n    println(\"Value range: \", summary[\"obs_stats\"].min, \" - \", summary[\"obs_stats\"].max)\nend\n\n# Check dimensions present in data\nfor (key, values) in summary\n    if isa(values, Vector) && !isempty(values)\n        println(key, \": \", length(values), \" unique values\")\n    end\nend\n\nSee also\n\nquery_sdmx_data, clean_sdmx_data\n\n\n\n\n\n","category":"function"},{"location":"api/validation/#Data-Validation","page":"Validation","title":"Data Validation","text":"Functions for validating data against SDMX schemas and standards.","category":"section"},{"location":"api/validation/#Main-Functions","page":"Validation","title":"Main Functions","text":"","category":"section"},{"location":"api/validation/#Types","page":"Validation","title":"Types","text":"","category":"section"},{"location":"api/validation/#SDMXer.create_validator","page":"Validation","title":"SDMXer.create_validator","text":"create_validator(schema::DataflowSchema; \n                strict_mode=false, \n                performance_mode=false,\n                auto_fix_enabled=true) -> SDMXValidator\n\nCreates a comprehensive SDMX validator with default validation rules and configurable behavior.\n\nThis constructor function creates a fully configured SDMXValidator instance loaded with all standard SDMX validation rules. The validator can be customized with different modes and settings to suit specific validation requirements.\n\nArguments\n\nschema::DataflowSchema: The target SDMX dataflow schema that defines validation requirements\n\nKeyword Arguments\n\nstrict_mode=false: Enable strict validation with lower tolerance for issues\nperformance_mode=false: Enable performance mode that skips expensive checks for large datasets\nauto_fix_enabled=true: Enable automatic fixing of correctable validation issues\n\nReturns\n\nSDMXValidator: Configured validator ready for dataset validation\n\nExamples\n\n# Create basic validator\nvalidator = create_validator(schema)\nresult = validator(data)\n\n# Create strict validator for critical data\nstrict_validator = create_validator(\n    schema,\n    strict_mode=true,\n    performance_mode=false,\n    auto_fix_enabled=false\n)\n\n# Create performance-optimized validator for large datasets\nfast_validator = create_validator(\n    schema,\n    strict_mode=false,\n    performance_mode=true,\n    auto_fix_enabled=true\n)\n\nSee also\n\nSDMXValidator, validate_sdmx_csv\n\n\n\n\n\n","category":"function"},{"location":"api/validation/#SDMXer.validate_sdmx_csv","page":"Validation","title":"SDMXer.validate_sdmx_csv","text":"validate_sdmx_csv(validator::SDMXValidator, \n                  data::DataFrame,\n                  dataset_name::String = \"unknown\") -> ValidationResult\n\nPerforms comprehensive validation of SDMX-CSV data against all configured validation rules.\n\nThis is the main validation function that executes all validation rules in the validator, collects issues, calculates compliance metrics, generates recommendations, and produces a complete validation report with performance statistics.\n\nArguments\n\nvalidator::SDMXValidator: Configured validator containing rules and schema\ndata::DataFrame: The SDMX-CSV dataset to validate\ndataset_name::String = \"unknown\": Name identifier for the dataset in reports\n\nReturns\n\nValidationResult: Comprehensive validation results including issues, scores, and recommendations\n\nExamples\n\n# Basic validation\nvalidator = create_validator(schema)\nresult = validate_sdmx_csv(validator, data, \"my_dataset\")\n\n# Check results\nprintln(\"Overall score: \", result.overall_score * 100, \"%\")\nprintln(\"Status: \", result.compliance_status)\nprintln(\"Issues found: \", length(result.issues))\n\n# Generate report\nreport = generate_validation_report(result)\nprintln(report)\n\n# Handle validation issues\ncritical_issues = filter(i -> i.severity == CRITICAL, result.issues)\nif !isempty(critical_issues)\n    println(\"CRITICAL: Dataset cannot be published\")\nend\n\nPerformance Notes\n\nValidation time scales with dataset size and number of enabled rules\nPerformance mode skips expensive checks for large datasets\nRule execution is timed individually for performance analysis\n\nSee also\n\nSDMXValidator, ValidationResult, generate_validation_report\n\n\n\n\n\n","category":"function"},{"location":"api/validation/#SDMXer.generate_validation_report","page":"Validation","title":"SDMXer.generate_validation_report","text":"generate_validation_report(result::ValidationResult;\n                          format::String = \"text\",\n                          include_details::Bool = true) -> String\n\nGenerates a formatted validation report.\n\nSee also\n\nvalidate_sdmx_csv, ValidationResult\n\n\n\n\n\n","category":"function"},{"location":"api/validation/#SDMXer.preview_validation_output","page":"Validation","title":"SDMXer.preview_validation_output","text":"preview_validation_output(result::ValidationResult; max_issues::Int = 10) -> String\n\nCreates a concise preview of validation results.\n\n\n\n\n\n","category":"function"},{"location":"api/validation/#SDMXer.ValidationResult","page":"Validation","title":"SDMXer.ValidationResult","text":"ValidationResult\n\nComprehensive validation results containing all validation issues, statistics, and actionable recommendations.\n\nThis struct represents the complete output of SDMX-CSV validation, providing detailed analysis of data quality, compliance status, and performance metrics along with specific recommendations for addressing any identified issues.\n\nFields\n\ndataset_name::String: Name or identifier of the validated dataset\nvalidation_timestamp::String: ISO timestamp when validation was performed\ntarget_schema::DataflowSchema: SDMX dataflow schema used for validation\ntotal_rows::Int: Total number of rows in the validated dataset\ntotal_columns::Int: Total number of columns in the validated dataset\nissues::Vector{ValidationIssue}: All validation issues found, ordered by severity\nstatistics::Dict{String, Any}: Detailed validation statistics and metrics\noverall_score::Float64: Overall compliance score (0.0-1.0, higher is better)\ncompliance_status::String: Overall compliance status (\"compliant\", \"minorissues\", \"majorissues\", \"non_compliant\")\nrecommendations::Vector{String}: Prioritized list of actionable recommendations\nperformance_metrics::Dict{String, Float64}: Validation performance timing and efficiency metrics\n\nExamples\n\n# Use validation result\nvalidator = create_validator(schema)\nresult = validate_sdmx_csv(validator, data, \"my_dataset\")\n\n# Check overall compliance\nprintln(\"Dataset score: \", result.overall_score * 100, \"%\")\nprintln(\"Status: \", result.compliance_status)\n\n# Show critical issues\ncritical_issues = filter(i -> i.severity == CRITICAL, result.issues)\nprintln(\"Critical issues: \", length(critical_issues))\n\n# Generate formatted report\nreport = generate_validation_report(result, format=\"text\")\nprintln(report)\n\nSee also\n\nvalidate_sdmx_csv, generate_validation_report\n\n\n\n\n\n","category":"type"},{"location":"api/validation/#SDMXer.ValidationRule","page":"Validation","title":"SDMXer.ValidationRule","text":"ValidationRule\n\nDefines a single validation rule with its criteria, evaluation logic, and optional auto-fix capabilities.\n\nThis struct encapsulates a complete validation rule that can be applied to SDMX data, including the logic to evaluate the rule, determine severity of violations, and optionally provide automatic fixes for common issues.\n\nFields\n\nrule_id::String: Unique identifier for the validation rule\nrule_name::String: Human-readable name of the validation rule\ndescription::String: Detailed description of what the rule checks\nseverity::ValidationSeverity: Severity level for violations of this rule\ncategory::String: Rule category (\"structure\", \"content\", \"quality\", \"compliance\")\nevaluation_function::Function: Function that evaluates the rule against data\nauto_fix_available::Bool: Whether automatic fixing is available for violations\nauto_fix_function::Union{Function, Nothing}: Function to automatically fix violations, if available\n\nExamples\n\n# Create a structure validation rule\nstructure_rule = ValidationRule(\n    \"REQ_COLS_001\",\n    \"Required Columns Present\",\n    \"Checks that all required SDMX columns are present\",\n    ERROR,\n    \"structure\",\n    (data, schema) -> check_required_columns(data, schema),\n    false,\n    nothing\n)\n\n# Create a rule with auto-fix capability\nformat_rule = ValidationRule(\n    \"FMT_001\",\n    \"Column Name Format\",\n    \"Ensures column names follow SDMX conventions\",\n    WARNING,\n    \"content\",\n    (data, schema) -> check_column_format(data),\n    true,\n    (data) -> fix_column_names(data)\n)\n\n# Use in validator\nvalidator = create_validator(schema)\nadd_custom_validation_rule(validator, structure_rule)\n\nSee also\n\nValidationSeverity, SDMXValidator\n\n\n\n\n\n","category":"type"},{"location":"api/validation/#SDMXer.ValidationSeverity","page":"Validation","title":"SDMXer.ValidationSeverity","text":"ValidationSeverity\n\nEnumeration for validation issue severity levels in SDMX data validation.\n\nThis enum defines the severity levels used to classify validation issues, helping users prioritize which problems to address first. Higher severity levels indicate more critical issues that prevent successful SDMX data processing.\n\nValues\n\nINFO = 1: Informational messages about data characteristics or suggestions\nWARNING = 2: Potential issues that may cause problems but don't prevent processing\nERROR = 3: Clear violations of SDMX standards that should be fixed\nCRITICAL = 4: Severe violations that prevent any further processing\n\nExamples\n\n# Create validation issues with different severities\ninfo_issue = ValidationIssue(\"Data completeness is 95%\", INFO)\nwarning_issue = ValidationIssue(\"Column name doesn't follow convention\", WARNING)\nerror_issue = ValidationIssue(\"Required column missing\", ERROR)\ncritical_issue = ValidationIssue(\"Invalid data structure\", CRITICAL)\n\n# Filter issues by severity\ncritical_issues = filter(issue -> issue.severity == CRITICAL, all_issues)\n\nSee also\n\nValidationRule, ValidationResult, SDMXValidator\n\n\n\n\n\n","category":"type"},{"location":"api/validation/#SDMXer.SDMXValidator","page":"Validation","title":"SDMXer.SDMXValidator","text":"SDMXValidator\n\nMain validation engine with configurable rules and settings for comprehensive SDMX data validation.\n\nThis mutable struct serves as the central validation engine, containing all the rules, configuration settings, and schema information needed to validate SDMX-CSV datasets. It supports both strict and performance modes, custom thresholds, and auto-fixing capabilities.\n\nFields\n\nschema::DataflowSchema: The target SDMX dataflow schema for validation\nvalidation_rules::Dict{String, ValidationRule}: Collection of validation rules indexed by rule ID\nstrict_mode::Bool: If true, applies stricter validation criteria with lower tolerance for issues\nperformance_mode::Bool: If true, skips expensive validation checks for large datasets\ncustom_thresholds::Dict{String, Float64}: Custom threshold values for validation rules\nauto_fix_enabled::Bool: Whether automatic issue fixing is enabled\n\nExamples\n\n# Create validator with default settings\nvalidator = create_validator(schema)\n\n# Validate a dataset\nresult = validator(data, \"my_dataset\")\n\n# Create validator with custom settings\nvalidator = create_validator(\n    schema, \n    strict_mode=true, \n    performance_mode=false,\n    auto_fix_enabled=true\n)\n\n# Add custom validation rules\ncustom_rule = ValidationRule(\n    \"custom_001\", \"Custom Check\", \"My custom validation\",\n    WARNING, \"quality\", my_validation_function, false, nothing\n)\nadd_custom_validation_rule(validator, custom_rule)\n\nSee also\n\ncreate_validator, validate_sdmx_csv, ValidationRule\n\n\n\n\n\n","category":"type"},{"location":"#SDMXer.jl-Documentation","page":"Home","title":"SDMXer.jl Documentation","text":"Core Julia package for SDMX (Statistical Data and Metadata eXchange) processing. Extract and analyze structural metadata from SDMX-ML documents.","category":"section"},{"location":"#Features","page":"Home","title":"Features","text":"Schema Extraction: Parse SDMX dataflow schemas from XML or APIs\nCodelist Processing: Extract and filter codelists with availability constraints\nData Availability Analysis: Understand data coverage and temporal ranges\nValidation Framework: Validate data against SDMX standards\nPipeline Operations: Chain operations with functional programming style\nData Queries: Construct and execute SDMX API queries","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"using Pkg\nPkg.add(\"SDMX\")","category":"section"},{"location":"#Quick-Example","page":"Home","title":"Quick Example","text":"using SDMXer, DataFrames\n\n# Extract SDMX schema from API\nurl = \"https://stats-sdmx-disseminate.pacificdata.org/rest/dataflow/SPC/DF_BP50/latest?references=all\"\nschema = extract_dataflow_schema(url)\n\n# Get codelists filtered by availability\ncodelists = extract_all_codelists(url, true)\n\n# Validate data against schema\nvalidator = create_validator(schema, codelists)\nresult = validate_sdmx_csv(validator, \"my_data.csv\")","category":"section"},{"location":"#Package-Structure","page":"Home","title":"Package Structure","text":"Schema & Metadata: Extract dataflow schemas, concepts, and structures\nCodelists: Process code lists with hierarchical relationships\nAvailability: Analyze data availability and temporal coverage\nValidation: Validate data quality and SDMX compliance\nData Queries: Construct and execute SDMX REST API queries\nPipelines: Functional operations for workflow composition","category":"section"},{"location":"#See-Also","page":"Home","title":"See Also","text":"SDMXerWizard.jl - LLM-powered extension for intelligent data transformation","category":"section"},{"location":"#SDMXer.SDMXer","page":"Home","title":"SDMXer.SDMXer","text":"SDMXer\n\nParse SDMX-ML structural metadata and data into Julia structures (DataFrames).\n\nWorkflow paths\n\nSchema extraction     extractdataflowschema  ─→  DataflowSchema                                    ├─→ compareschemas  ─→  SchemaComparison                                    ├─→ createvalidator ─→  validatesdmxcsv ─→ generatevalidationreport                                    └─→ querysdmxdata  ─→  DataFrame\n\nCodelist processing     extractallcodelists  ─→  DataFrame     filtercodelistsby_availability  ─→  filtered DataFrame\n\nData availability     extractavailability  ─→  AvailabilityConstraint     compareschemaavailability  /  getdatacoveragesummary  /  finddatagaps\n\nData querying     constructdataurl  ─→  URL string     querysdmxdata    ─→  DataFrame  (fetch + parse in one step)     fetchsdmxdata    ─→  raw CSV string\n\nValidation     createvalidator  ─→  SDMXValidator     validatesdmxcsv ─→  ValidationResult     generatevalidation_report  ─→  formatted report string\n\nCross-dataflow join (horizontal)     compareschemas       ─→  SchemaComparison     detectunitconflicts ─→  UnitConflictReport     harmonizeunits       ─→  (DataFrame, DataFrame)     alignfrequencies     ─→  FrequencyAlignment     detectjoincolumns   ─→  Vector{String}     sdmxjoin             ─→  JoinResult\n\nCross-dataflow combine (vertical)     sdmxcombine    ─→  CombineResult     pivotsdmx_wide ─→  DataFrame\n\nPipeline operators     chain  /  pipeline  /  tap  /  branch  /  parallel_map     ⊆  (subset)  /  ⇒  (pipe)\n\nUnits & conversion     sdmxtounitful  ─→  SDMXUnitSpec     areunitsconvertible  /  conversionfactor  /  unitmultiplier     ExchangeRateTable: addrate!, getrate, convert_currency\n\nCore types\n\nDataflowSchema: dimensions, attributes, codelists, and metadata for a dataflow\nAvailabilityConstraint: which dimension values and time periods have data\nValidationResult: outcome of validating a CSV against a schema\nSchemaComparison: shared/unique dimensions and codelist overlaps between two schemas\nUnitConflictReport: unit mismatches detected between two DataFrames\nJoinResult: joined DataFrame plus diagnostics from sdmx_join\nCombineResult: vertically stacked DataFrame plus diagnostics from sdmx_combine\nFrequencyAlignment: frequency conversion metadata from align_frequencies\nSDMXUnitSpec: Unitful mapping for an SDMX unit code\nExchangeRateTable: currency exchange rates for unit harmonization\n\nUtilities\n\nfetch_sdmx_xml: auto-detects URL / XML string / file path and returns an EzXML document\nnormalize_sdmx_url: normalises SDMX REST URLs to canonical form\nclean_sdmx_data: type-coerce and tidy a raw SDMX CSV DataFrame\nsummarize_data: quick summary statistics for an SDMX DataFrame\n\nSee also: SDMXerWizard (SDMXLLM.jl) for LLM-powered mapping, script generation, and workflow orchestration.\n\n\n\n\n\n","category":"module"}]
}
