var documenterSearchIndex = {"docs":
[{"location":"api/pipelines/#Pipeline-Operations","page":"Pipelines","title":"Pipeline Operations","text":"","category":"section"},{"location":"api/pipelines/","page":"Pipelines","title":"Pipelines","text":"Functional programming interface for chaining SDMX operations.","category":"page"},{"location":"api/pipelines/#Main-Functions","page":"Pipelines","title":"Main Functions","text":"","category":"section"},{"location":"api/pipelines/#SDMX.validate_with","page":"Pipelines","title":"SDMX.validate_with","text":"validate_with(schema::DataflowSchema; kwargs...) -> Function\n\nCreates a validation function for use in data processing pipelines.\n\nThis function returns a closure that can be used with Julia's pipe operator to validate DataFrames against SDMX schemas in a functional programming style.\n\nArguments\n\nschema::DataflowSchema: The SDMX dataflow schema to validate against\nkwargs...: Additional keyword arguments passed to the validator\n\nReturns\n\nFunction: A function that takes a DataFrame and returns a ValidationResult\n\nExamples\n\nresult = my_data |> validate_with(schema; strict_mode=true)\nvalidator_func = validate_with(schema; performance_mode=true)\nresult = validator_func(my_data)\n\nSee also\n\n⇒, create_validator\n\n\n\n\n\n","category":"function"},{"location":"api/pipelines/#SDMX.chain","page":"Pipelines","title":"SDMX.chain","text":"chain(operations...) -> Function\n\nCreates a composable chain of operations for data processing workflows.\n\nThis function creates a single function that applies a sequence of operations in order, passing the result of each operation to the next. It's useful for building complex data transformation pipelines.\n\nArguments\n\noperations...: Variable number of functions to chain together\n\nReturns\n\nFunction: A function that applies all operations sequentially to input data\n\nExamples\n\nprocessor = chain(\n    validate_with(schema),\n    profile_with(\"my_data.csv\"),\n    data -> transform_data(data)\n)\n\nresult = my_data |> processor\n\n# More complex example\nanalysis_pipeline = chain(\n    validate_with(schema; strict_mode=true),\n    profile_with(\"dataset\"),\n    data -> (data, infer_mappings(data, schema))\n)\n\nSee also\n\npipeline, SDMXPipeline\n\n\n\n\n\n","category":"function"},{"location":"api/pipelines/#SDMX.pipeline","page":"Pipelines","title":"SDMX.pipeline","text":"pipeline(operations...) -> SDMXPipeline\n\nCreate an SDMX processing pipeline with chainable operations.\n\nThis function constructs an SDMXPipeline that can be reused and applied to different datasets using Julia's pipe operator syntax.\n\nArguments\n\noperations...: Variable number of functions to include in the pipeline\n\nReturns\n\nSDMXPipeline: A pipeline object that can be applied to data\n\nExamples\n\nmy_pipeline = pipeline(\n    validate_with(schema; strict_mode=true),\n    profile_with(\"dataset.csv\")\n)\n\n# Execute the pipeline\nresult = my_data |> my_pipeline\n\n# Reusable pipeline for multiple datasets\nstandard_pipeline = pipeline(\n    validate_with(schema),\n    profile_with(\"data\")\n)\n\nresults = [dataset1, dataset2] .|> Ref(standard_pipeline)\n\nSee also\n\nSDMXPipeline, chain\n\n\n\n\n\n","category":"function"},{"location":"api/pipelines/#SDMX.tap","page":"Pipelines","title":"SDMX.tap","text":"tap(f::Function) -> Function\n\nCreates a \"tap\" function for side effects in pipelines without modifying data flow.\n\nThis function allows you to perform side effects (like logging, printing, or debugging) at any point in a pipeline without affecting the data being passed through. The original data is always returned unchanged.\n\nArguments\n\nf::Function: Function to call for side effects, receives the data as input\n\nReturns\n\nFunction: A function that applies the side effect and returns the original data\n\nExamples\n\nresult = my_data |>\n    tap(d -> println(\"Processing $(nrow(d)) rows\")) |>\n    validate_with(schema) |>\n    tap(r -> println(\"Validation score: $(r.overall_score)\"))\n\n# Debugging pipeline\ndebug_pipeline = pipeline(\n    tap(data -> @info \"Input data size: $(size(data))\"),\n    validate_with(schema),\n    tap(result -> @info \"Validation result: $(result.is_valid)\")\n)\n\nSee also\n\nchain, pipeline\n\n\n\n\n\n","category":"function"},{"location":"api/pipelines/#SDMX.branch","page":"Pipelines","title":"SDMX.branch","text":"branch(condition::Function, true_path::Function, false_path::Function=identity) -> Function\n\nCreates conditional branching in data processing pipelines.\n\nThis function allows pipelines to take different processing paths based on runtime conditions, enabling adaptive data processing workflows.\n\nArguments\n\ncondition::Function: Function that takes data and returns a boolean\ntrue_path::Function: Function to apply when condition is true\nfalse_path::Function=identity: Function to apply when condition is false (default: identity)\n\nReturns\n\nFunction: A function that applies conditional logic to input data\n\nExamples\n\nresult = my_data |>\n    branch(\n        data -> nrow(data) > 1000,\n        validate_with(schema; performance_mode=true),  # Large dataset path\n        validate_with(schema; strict_mode=true)        # Small dataset path\n    )\n\n# Handle missing data differently\nprocessor = branch(\n    data -> any(ismissing, eachcol(data)),\n    data -> impute_missing(data),  # Has missing values\n    identity                       # No missing values\n)\n\nSee also\n\ntap, chain\n\n\n\n\n\n","category":"function"},{"location":"api/pipelines/#SDMX.parallel_map","page":"Pipelines","title":"SDMX.parallel_map","text":"parallel_map(f::Function) -> Function\n\nCreates a parallel mapping function for concurrent data processing.\n\nThis function creates a parallel version of map that can process multiple datasets or collections concurrently, improving performance for CPU-intensive SDMX operations.\n\nArguments\n\nf::Function: Function to apply to each element in parallel\n\nReturns\n\nFunction: A function that applies f to collections in parallel using threading\n\nExamples\n\n# Process multiple datasets in parallel\nresults = datasets |> parallel_map(validate_with(schema))\n\n# Parallel profiling of multiple files\nprofiles = data_files |> parallel_map(profile_with(\"batch_analysis\"))\n\n# Apply transformation to multiple dataframes\ntransformed = dataframes |> parallel_map(data -> transform(data, :col => :new_col))\n\nThrows\n\nBoundsError: If collections are empty\n\nSee also\n\nchain\n\n\n\n\n\n","category":"function"},{"location":"api/pipelines/#Types","page":"Pipelines","title":"Types","text":"","category":"section"},{"location":"api/pipelines/#SDMX.SDMXPipeline","page":"Pipelines","title":"SDMX.SDMXPipeline","text":"SDMXPipeline{T}\n\nA composable pipeline structure for complete SDMX data processing workflows.\n\nThis struct wraps a collection of operations that can be applied sequentially to data, providing a reusable and composable approach to SDMX data processing.\n\nFields\n\noperations::T: Tuple or collection of operations to be applied in sequence\n\nExamples\n\nmy_pipeline = pipeline(\n    validate_with(schema),\n    profile_with(\"dataset.csv\")\n)\n\nresult = my_data |> my_pipeline\n\nSee also\n\npipeline, chain\n\n\n\n\n\n","category":"type"},{"location":"api/pipelines/#Pipeline-Operators","page":"Pipelines","title":"Pipeline Operators","text":"","category":"section"},{"location":"api/pipelines/#Base.:⊆","page":"Pipelines","title":"Base.:⊆","text":"⊆(data::DataFrame, schema::DataflowSchema) -> Bool\n\nSchema compliance operator using subset symbol.\n\nReturns true if data structure is a subset/compliant with schema requirements. This operator provides an intuitive way to check if a DataFrame conforms to the structure defined by an SDMX dataflow schema.\n\nArguments\n\ndata::DataFrame: The DataFrame to validate against the schema\nschema::DataflowSchema: The SDMX dataflow schema to check compliance against\n\nReturns\n\nBool: true if data structure complies with schema requirements, false otherwise\n\nExamples\n\nis_compliant = my_data ⊆ schema\nif my_data ⊆ schema\n    println(\"Data is schema compliant!\")\nend\n\nSee also\n\n⇒, validate_with\n\n\n\n\n\n","category":"function"},{"location":"api/pipelines/#SDMX.:⇒","page":"Pipelines","title":"SDMX.:⇒","text":"⇒(data::DataFrame, validator::SDMXValidator) -> ValidationResult\n\nData flow operator for direct DataFrame validation.\n\nProvides a pipeline-friendly operator for applying SDMX validation to DataFrames. The arrow symbol suggests the flow of data through the validation process.\n\nArguments\n\ndata::DataFrame: The DataFrame to validate\nvalidator::SDMXValidator: The validator to apply to the data\n\nReturns\n\nValidationResult: The result of the validation process\n\nExamples\n\nresult = my_data ⇒ validator\nif (my_data ⇒ validator).is_valid\n    println(\"Validation passed!\")\nend\n\nSee also\n\n⊆, validate_with\n\n\n\n\n\n","category":"function"},{"location":"api/elements/#SDMX-Element-Types","page":"Elements","title":"SDMX Element Types","text":"","category":"section"},{"location":"api/elements/","page":"Elements","title":"Elements","text":"Type-specialized parsing system using @generated functions for compile-time optimization.","category":"page"},{"location":"api/elements/#Element-Types","page":"Elements","title":"Element Types","text":"","category":"section"},{"location":"api/elements/#SDMX.SDMXElement","page":"Elements","title":"SDMX.SDMXElement","text":"SDMXElement\n\nAbstract base type for all SDMX element types used in generated function dispatch.\n\nThis type hierarchy enables compile-time specialization of parsing functions, allowing the Julia compiler to generate optimized code paths for each specific SDMX element type without runtime type checking overhead.\n\nSee also\n\nextract_sdmx_element, DimensionElement, AttributeElement\n\n\n\n\n\n","category":"type"},{"location":"api/elements/#SDMX.DimensionElement","page":"Elements","title":"SDMX.DimensionElement","text":"DimensionElement <: SDMXElement\n\nType representing SDMX dimension elements for specialized parsing.\n\nDimensions define the key attributes that categorize statistical data in SDMX datasets. This type enables compile-time generation of optimized parsing code for dimension structures including concept references, codelist bindings, and position information.\n\nExamples\n\n# Use with generated parsing function\ndimension_data = extract_sdmx_element(DimensionElement, dimension_node)\nprintln(dimension_data.dimension_id)\nprintln(dimension_data.position)\n\nSee also\n\nextract_sdmx_element, AttributeElement, MeasureElement\n\n\n\n\n\n","category":"type"},{"location":"api/elements/#SDMX.AttributeElement","page":"Elements","title":"SDMX.AttributeElement","text":"AttributeElement <: SDMXElement\n\nType representing SDMX attribute elements for specialized parsing.\n\nAttributes provide additional metadata about statistical observations in SDMX datasets. This type enables compile-time generation of optimized parsing code for attribute structures including assignment status, attachment levels, and concept references.\n\nExamples\n\n# Use with generated parsing function\nattribute_data = extract_sdmx_element(AttributeElement, attribute_node)\nprintln(attribute_data.attribute_id)\nprintln(attribute_data.assignment_status)\n\nSee also\n\nextract_sdmx_element, DimensionElement, MeasureElement\n\n\n\n\n\n","category":"type"},{"location":"api/elements/#SDMX.MeasureElement","page":"Elements","title":"SDMX.MeasureElement","text":"MeasureElement <: SDMXElement\n\nType representing SDMX measure elements for specialized parsing.\n\nMeasures define the actual statistical values being reported in SDMX datasets. This type enables compile-time generation of optimized parsing code for measure structures including data types, units of measure, and concept references.\n\nExamples\n\n# Use with generated parsing function\nmeasure_data = extract_sdmx_element(MeasureElement, measure_node)\nprintln(measure_data.measure_id)\nprintln(measure_data.data_type)\n\nSee also\n\nextract_sdmx_element, DimensionElement, AttributeElement\n\n\n\n\n\n","category":"type"},{"location":"api/elements/#SDMX.ConceptElement","page":"Elements","title":"SDMX.ConceptElement","text":"ConceptElement <: SDMXElement\n\nType representing SDMX concept elements for specialized parsing.\n\nConcepts define the semantic meaning of dimensions, attributes, and measures in SDMX. This type enables compile-time generation of optimized parsing code for concept structures including names, descriptions, and classifications.\n\nExamples\n\n# Use with generated parsing function\nconcept_data = extract_sdmx_element(ConceptElement, concept_node)\nprintln(concept_data.concept_id)\nprintln(concept_data.name)\n\nSee also\n\nextract_sdmx_element, CodelistElement\n\n\n\n\n\n","category":"type"},{"location":"api/elements/#SDMX.CodelistElement","page":"Elements","title":"SDMX.CodelistElement","text":"CodelistElement <: SDMXElement\n\nType representing SDMX codelist elements for specialized parsing.\n\nCodelists define the valid values (codes) that can be used for dimensions and attributes. This type enables compile-time generation of optimized parsing code for codelist structures including code hierarchies, names, and parent-child relationships.\n\nExamples\n\n# Use with generated parsing function\ncodelist_data = extract_sdmx_element(CodelistElement, codelist_node)\nprintln(codelist_data.codelist_id)\nprintln(codelist_data.codes)\n\nSee also\n\nextract_sdmx_element, ConceptElement\n\n\n\n\n\n","category":"type"},{"location":"api/elements/#SDMX.AvailabilityElement","page":"Elements","title":"SDMX.AvailabilityElement","text":"AvailabilityElement <: SDMXElement\n\nType representing SDMX availability constraint elements for specialized parsing.\n\nAvailability constraints define what data is actually available for specific dimensions and time periods. This type enables compile-time generation of optimized parsing code for availability structures including dimension values and time ranges.\n\nExamples\n\n# Use with generated parsing function\navailability_data = extract_sdmx_element(AvailabilityElement, availability_node)\nprintln(availability_data.dimension_values)\nprintln(availability_data.time_periods)\n\nSee also\n\nextract_sdmx_element, TimeElement\n\n\n\n\n\n","category":"type"},{"location":"api/elements/#SDMX.TimeElement","page":"Elements","title":"SDMX.TimeElement","text":"TimeElement <: SDMXElement\n\nType representing SDMX time dimension elements for specialized parsing.\n\nTime elements define temporal aspects of statistical data including periods, frequency, and time ranges. This type enables compile-time generation of optimized parsing code for time structures including start/end dates and period formats.\n\nExamples\n\n# Use with generated parsing function\ntime_data = extract_sdmx_element(TimeElement, time_node)\nprintln(time_data.start_period)\nprintln(time_data.end_period)\n\nSee also\n\nextract_sdmx_element, AvailabilityElement\n\n\n\n\n\n","category":"type"},{"location":"api/elements/#Extraction-Functions","page":"Elements","title":"Extraction Functions","text":"","category":"section"},{"location":"api/elements/#SDMX.extract_sdmx_element","page":"Elements","title":"SDMX.extract_sdmx_element","text":"extract_sdmx_element(::Type{T}, node::EzXML.Node) where T <: SDMXElement -> NamedTuple\n\nExtract SDMX element data using compile-time specialized parsing based on element type.\n\nThis @generated function creates type-specialized parsing code at compile time, eliminating runtime type checking and providing optimized XPath queries and field extraction for each SDMX element type.\n\nArguments\n\n::Type{T}: SDMX element type for compile-time specialization\nnode::EzXML.Node: XML node containing the SDMX element data\n\nReturns\n\nNamedTuple: Extracted element data with fields specific to the element type\n\nExamples\n\n# Parse different SDMX elements with specialized code\ndimension_data = extract_sdmx_element(DimensionElement, dim_node)\nattribute_data = extract_sdmx_element(AttributeElement, attr_node)\nmeasure_data = extract_sdmx_element(MeasureElement, measure_node)\n\n# Access type-specific fields\nprintln(dimension_data.dimension_id)    # Only available for dimensions\nprintln(attribute_data.assignment_status)  # Only available for attributes\nprintln(measure_data.data_type)         # Only available for measures\n\nPerformance\n\nThis generated function provides significant performance improvements over runtime dispatch:\n\n30-50% reduction in parsing time\n20-40% reduction in memory allocations\nBetter scaling with large SDMX documents\n\nSee also\n\nget_xpath_patterns, DimensionElement\n\n\n\n\n\n","category":"function"},{"location":"api/elements/#SDMX.extract_generic_element","page":"Elements","title":"SDMX.extract_generic_element","text":"extract_generic_element(node::EzXML.Node) -> NamedTuple\n\nFallback generic extraction for unsupported element types.\n\nThis function provides a safety net for element types that don't have specialized @generated function implementations.\n\n\n\n\n\n","category":"function"},{"location":"api/elements/#SDMX.extract_code_info","page":"Elements","title":"SDMX.extract_code_info","text":"extract_code_info(code_node::EzXML.Node) -> NamedTuple\n\nExtract information from a single code node in a codelist.\n\nThis helper function is used by the generated codelist extraction to process individual code elements efficiently.\n\n\n\n\n\n","category":"function"},{"location":"api/elements/#SDMX.get_xpath_patterns","page":"Elements","title":"SDMX.get_xpath_patterns","text":"get_xpath_patterns(::Type{T}) where T <: SDMXElement -> NamedTuple\n\nGenerate compile-time XPath patterns for specific SDMX element types.\n\nThis @generated function provides type-specialized XPath patterns that are compiled at build time, eliminating runtime XPath string construction and parsing overhead.\n\nArguments\n\n::Type{T}: SDMX element type for compile-time specialization\n\nReturns\n\nNamedTuple: XPath patterns specific to the element type\n\nExamples\n\n# Get compile-time XPath patterns\ndim_patterns = get_xpath_patterns(DimensionElement)\nattr_patterns = get_xpath_patterns(AttributeElement)\n\n# Patterns are available at compile time\nprintln(dim_patterns.concept_ref)    # \".//structure:ConceptIdentity/Ref\"\nprintln(attr_patterns.attachment)    # \".//structure:AttributeRelationship\"\n\nSee also\n\nextract_sdmx_element\n\n\n\n\n\n","category":"function"},{"location":"api/elements/#Demonstrations","page":"Elements","title":"Demonstrations","text":"","category":"section"},{"location":"api/elements/#SDMX.demonstrate_generated_parsing","page":"Elements","title":"SDMX.demonstrate_generated_parsing","text":"demonstrate_generated_parsing(; verbose::Bool=true) -> Nothing\n\nDemonstrate the usage of generated function SDMX parsing with examples.\n\nThis function provides a comprehensive demonstration of how to use the new @generated function system for parsing different types of SDMX elements, showing the performance benefits and ease of use.\n\nArguments\n\nverbose::Bool=true: Whether to print output. Set to false for quiet operation during tests.\n\nExamples\n\n# Run the full demonstration with output\ndemonstrate_generated_parsing()\n\n# Run quietly (for testing)\ndemonstrate_generated_parsing(verbose=false)\n\n# This will show examples of:\n# - Type-specialized parsing for different element types\n# - Performance comparisons with traditional methods\n# - Integration with existing SDMX workflows\n\nSee also\n\nextract_sdmx_element\n\n\n\n\n\n","category":"function"},{"location":"api/elements/#SDMX.create_benchmark_xml","page":"Elements","title":"SDMX.create_benchmark_xml","text":"create_benchmark_xml() -> String\n\nCreate sample XML content for benchmarking generated function performance.\n\n\n\n\n\n","category":"function"},{"location":"api/elements/#SDMX.migration_guide","page":"Elements","title":"SDMX.migration_guide","text":"migration_guide(; verbose::Bool=true) -> Nothing\n\nProvide a comprehensive guide for migrating to generated function parsing.\n\nThis function explains how to update existing code to use the new @generated function system while maintaining compatibility and gaining performance benefits.\n\nArguments\n\nverbose::Bool=true: Whether to print output. Set to false for quiet operation during tests.\n\nExamples\n\n# Display migration instructions\nmigration_guide()\n\n# Run quietly (for testing)\nmigration_guide(verbose=false)\n\nSee also\n\nextract_sdmx_element, demonstrate_generated_parsing\n\n\n\n\n\n","category":"function"},{"location":"api/codelists/#Codelists","page":"Codelists","title":"Codelists","text":"","category":"section"},{"location":"api/codelists/","page":"Codelists","title":"Codelists","text":"Functions for extracting and processing SDMX codelists.","category":"page"},{"location":"api/codelists/#Main-Functions","page":"Codelists","title":"Main Functions","text":"","category":"section"},{"location":"api/codelists/#SDMX.extract_all_codelists","page":"Codelists","title":"SDMX.extract_all_codelists","text":"extract_all_codelists(doc::EzXML.Document) -> DataFrame\n\nThe primary extraction function for a SDMX-like dataflow document. It operates on an XML object (namely, an already-parsed EzXML.Document object).\n\nThis function traverses the document to find all <structure:Codelist> elements. For each codelist, it extracts all child <structure:Code> elements, capturing their IDs, names, annotations, and the ID of the parent codelist to ensure uniqueness. The results from all codelists are aggregated into a single, tidy DataFrame.\n\nArguments\n\ndoc::EzXML.Document: A parsed XML document object from which to extract data.\n\nReturns\n\nDataFrame: A tidy DataFrame containing all codes from all codelists in the document. The columns are:\ncodelist_id::String\ncode_id::String\nlang::Union{String, Missing}\nname::Union{String, Missing}\nparent_code_id::Union{String, Missing}\norder::Union{String, Missing}\n\nIf no codelists or codes are found, it returns an empty DataFrame with the correct schema.\n\n\n\n\n\nextract_all_codelists(input::String) -> DataFrame\n\nExtracts all codelist data from a URL or XML string. Automatically detects whether the input is a URL or XML content.\n\nArguments\n\ninput::String: Either a URL to fetch SDMX XML data from, or raw XML content as a string.\n\nReturns\n\nDataFrame: A tidy DataFrame containing all codes from all codelists.\n\nExamples\n\n# From URL\ncodelists = extract_all_codelists(\"https://example.com/dataflow.xml\")\n\n# From XML string\ncodelists = extract_all_codelists(xml_string)\n\n\n\n\n\nextract_all_codelists(url::String, filter_by_availability::Bool) -> DataFrame\n\nExtract codelists with automatic availability filtering.\n\nArguments\n\nurl::String: The dataflow URL to fetch the XML from.\nfilter_by_availability::Bool: If true, automatically constructs availability URL and filters codes\n\nReturns\n\nDataFrame: A tidy DataFrame containing only codes that actually appear in published data.\n\nExamples\n\n# Get only codes that have actual published data (auto-constructed availability URL)\navailable_codes = extract_all_codelists(dataflow_url, true)\n\n\n\n\n\nextract_all_codelists(url::String, availability_url::String) -> DataFrame\n\nExtract codelists with custom availability URL filtering.\n\nArguments\n\nurl::String: The dataflow URL to fetch the XML from.\navailability_url::String: Custom availability constraint URL (can include dimension filters)\n\nReturns\n\nDataFrame: A tidy DataFrame containing only codes that appear in the specified availability constraint.\n\nExamples\n\n# Use custom availability URL with dimension filters\navailable_codes = extract_all_codelists(dataflow_url, \n    \"https://stats-sdmx-disseminate.pacificdata.org/rest/availableconstraint/DF_BP50/A..NR........\")\n\n# Standard availability URL\navailable_codes = extract_all_codelists(dataflow_url,\n    \"https://stats-sdmx-disseminate.pacificdata.org/rest/availableconstraint/DF_DISABILITY/\")\n\n\n\n\n\n","category":"function"},{"location":"api/codelists/#SDMX.filter_codelists_by_availability","page":"Codelists","title":"SDMX.filter_codelists_by_availability","text":"filter_codelists_by_availability(codelists_df::DataFrame, dataflow_url::String, availability_url::String=\"\") -> DataFrame\n\nFilters a codelists DataFrame to include only codes that actually appear in published data.\n\nArguments\n\ncodelists_df::DataFrame: The full codelists DataFrame to filter\ndataflow_url::String: The original dataflow URL (used to construct availability URL if needed)\navailability_url::String: Explicit availability constraint URL (optional)\n\nReturns\n\nDataFrame: Filtered codelists containing only codes with actual published data\n\n\n\n\n\n","category":"function"},{"location":"api/codelists/#SDMX.get_available_codelist_summary","page":"Codelists","title":"SDMX.get_available_codelist_summary","text":"get_available_codelist_summary(dataflow_url::String; availability_url::String=\"\") -> Dict{String, Any}\n\nGets a summary of codelist availability without downloading full codelists.\n\nReturns information about which dimensions have data and how many values are available.\n\n\n\n\n\n","category":"function"},{"location":"api/codelists/#SDMX.map_codelist_to_dimension","page":"Codelists","title":"SDMX.map_codelist_to_dimension","text":"map_codelist_to_dimension(codelist_id::String) -> Union{String, Nothing}\n\nMaps a codelist ID to its corresponding dimension ID using common SDMX patterns. Returns nothing if no mapping can be determined.\n\nExamples\n\n\"CLGEOPICT\" -> \"GEO_PICT\"  \n\"CL_INDICATOR\" -> \"INDICATOR\"\n\"CL_FREQ\" -> \"FREQ\"\n\"INDICATOR\" -> \"INDICATOR\" (direct match)\n\n\n\n\n\n","category":"function"},{"location":"api/codelists/#Utilities","page":"Codelists","title":"Utilities","text":"","category":"section"},{"location":"api/codelists/#SDMX.construct_availability_url","page":"Codelists","title":"SDMX.construct_availability_url","text":"construct_availability_url(dataflow_url::String) -> String\n\nAttempts to construct an availability constraint URL from a dataflow URL.\n\nSupports common SDMX URL patterns like:\n\n.../rest/dataflow/AGENCY/DATAFLOW_ID/VERSION?references=all \n.../rest/dataflow/DATAFLOW_ID/VERSION?references=all\n\n\n\n\n\n","category":"function"},{"location":"api/schema/#Schema-and-Metadata","page":"Schema & Metadata","title":"Schema & Metadata","text":"","category":"section"},{"location":"api/schema/","page":"Schema & Metadata","title":"Schema & Metadata","text":"Functions for extracting and analyzing SDMX dataflow schemas and metadata.","category":"page"},{"location":"api/schema/#Main-Functions","page":"Schema & Metadata","title":"Main Functions","text":"","category":"section"},{"location":"api/schema/#SDMX.extract_dataflow_schema","page":"Schema & Metadata","title":"SDMX.extract_dataflow_schema","text":"extract_dataflow_schema(doc::EzXML.Document) -> DataflowSchema\n\nExtracts complete dataflow schema information from an SDMX structure document.\n\nArguments\n\ndoc::EzXML.Document: The parsed SDMX XML document.\n\nReturns\n\nDataflowSchema: A comprehensive schema object with all dataflow structure information.\n\n\n\n\n\nextract_dataflow_schema(input::String) -> DataflowSchema\n\nExtracts dataflow schema from SDMX-ML content provided as URL or XML string.\n\nThis convenience function automatically handles both URL-based SDMX API calls and direct XML string parsing. It downloads schema information from SDMX web services or processes local XML content to build a complete DataflowSchema.\n\nArguments\n\ninput::String: Either a URL to SDMX dataflow schema or raw SDMX-ML XML content\n\nReturns\n\nDataflowSchema: Complete schema with dimensions, attributes, measures, and metadata\n\nExamples\n\n# Extract from SDMX API URL\nurl = \"https://stats-sdmx-disseminate.pacificdata.org/rest/datastructure/SPC/DF_BP50\"\nschema = extract_dataflow_schema(url)\n\n# Extract from local XML file content\nxml_content = read(\"dataflow.xml\", String)\nschema = extract_dataflow_schema(xml_content)\n\n# Use the schema\nprintln(\"Dataflow: \", schema.dataflow_info.name)\nprintln(\"Dimensions: \", nrow(schema.dimensions))\nprintln(\"Attributes: \", nrow(schema.attributes))\n\nThrows\n\nHTTP.ExceptionRequest.StatusError: If URL request fails\nEzXML.XMLError: If XML parsing fails\nKeyError: If required SDMX elements are missing\n\nSee also\n\nextract_dataflow_schema(::EzXML.Document), DataflowSchema, fetch_sdmx_xml\n\n\n\n\n\n","category":"function"},{"location":"api/schema/#SDMX.extract_concepts","page":"Schema & Metadata","title":"SDMX.extract_concepts","text":"extract_concepts(doc::EzXML.Document) -> DataFrame\n\nExtracts concept definitions and their structural roles from SDMX documents.\n\nThis function parses SDMX structure documents to extract concept schemas, including concept identifiers, descriptions, variable mappings, and their roles within the data structure (dimension, attribute, measure, or time dimension).\n\nArguments\n\ndoc::EzXML.Document: Parsed SDMX XML structure document\n\nReturns\n\nDataFrame: Concept definitions with columns:\nconcept_id::String: Unique concept identifier\ndescription::Union{String,Missing}: Human-readable concept description\nvariable::String: Variable identifier used in data structure\nrole::String: Structural role (\"dimension\", \"attribute\", \"measure\", \"time_dimension\")\n\nExamples\n\n# Extract from parsed XML document\ndoc = parsexml(xml_string)\nconcepts = extract_concepts(doc)\n\n# View concept roles\nprintln(\"Dimensions: \", filter(r -> r.role == \"dimension\", concepts).concept_id)\nprintln(\"Measures: \", filter(r -> r.role == \"measure\", concepts).concept_id)\n\n# Find concept descriptions\nconcept_desc = Dict(c.concept_id => c.description for c in eachrow(concepts))\n\nSee also\n\nextract_concepts, extract_dataflow_schema\n\n\n\n\n\nextract_concepts(input::String) -> DataFrame\n\nConvenience function for concept extraction from URLs or XML strings.\n\nThis function automatically handles URL fetching and XML parsing, providing a simple interface for concept extraction from either SDMX REST API endpoints or XML content strings. It includes error handling for network and parsing issues.\n\nArguments\n\ninput::String: Either a URL to SDMX structure endpoint or XML content string\n\nReturns\n\nDataFrame: Concept definitions (same structure as document-based extraction),  or empty DataFrame with correct schema if extraction fails\n\nExamples\n\n# Extract from SDMX REST API URL\nurl = \"https://stats-sdmx-disseminate.pacificdata.org/rest/datastructure/SPC/DF_BP50/1.0\"\nconcepts = extract_concepts(url)\n\n# Extract from XML string\nxml_content = read(\"datastructure.xml\", String)\nconcepts = extract_concepts(xml_content)\n\n# Handle potential failures gracefully\nconcepts = extract_concepts(possibly_invalid_url)\nif nrow(concepts) == 0\n    println(\"No concepts extracted - check URL or XML format\")\nelse\n    println(\"Extracted \", nrow(concepts), \" concept definitions\")\nend\n\nSee also\n\nextract_concepts, fetch_sdmx_xml\n\n\n\n\n\n","category":"function"},{"location":"api/schema/#Schema-Inspection","page":"Schema & Metadata","title":"Schema Inspection","text":"","category":"section"},{"location":"api/schema/#SDMX.get_required_columns","page":"Schema & Metadata","title":"SDMX.get_required_columns","text":"get_required_columns(schema::DataflowSchema) -> Vector{String}\n\nReturns a vector of column names that are required for SDMX-CSV output. This includes all dimensions, the primary measure, and mandatory attributes.\n\n\n\n\n\n","category":"function"},{"location":"api/schema/#SDMX.get_optional_columns","page":"Schema & Metadata","title":"SDMX.get_optional_columns","text":"get_optional_columns(schema::DataflowSchema) -> Vector{String}\n\nReturns a vector of column names that are optional for SDMX-CSV output. This includes conditional attributes.\n\n\n\n\n\n","category":"function"},{"location":"api/schema/#SDMX.get_codelist_columns","page":"Schema & Metadata","title":"SDMX.get_codelist_columns","text":"get_codelist_columns(schema::DataflowSchema) -> Dict{String, NamedTuple}\n\nReturns a dictionary mapping column names to their codelist information. Only includes columns that have associated codelists.\n\n\n\n\n\n","category":"function"},{"location":"api/schema/#SDMX.get_dimension_order","page":"Schema & Metadata","title":"SDMX.get_dimension_order","text":"get_dimension_order(schema::DataflowSchema) -> Vector{String}\n\nReturns the ordered list of dimension IDs for constructing SDMX data query keys. Dimensions are ordered by their position, with the time dimension (if present) included.\n\n\n\n\n\n","category":"function"},{"location":"api/schema/#Types","page":"Schema & Metadata","title":"Types","text":"","category":"section"},{"location":"api/schema/#SDMX.DataflowSchema","page":"Schema & Metadata","title":"SDMX.DataflowSchema","text":"DataflowSchema\n\nComplete schema information for an SDMX dataflow including structure, dimensions, and metadata.\n\nThis struct contains all essential schema information needed to validate, transform, and work with SDMX-CSV data. It provides comprehensive metadata about the dataflow structure, dimension ordering, attribute requirements, and measure definitions.\n\nFields\n\ndataflow_info::NamedTuple: Basic dataflow metadata including id, agency, version, name, and description\ndimensions::DataFrame: All dimensions with position ordering, concept references, and codelist information\nattributes::DataFrame: All attributes with assignment status (required/conditional), concept and codelist info  \nmeasures::DataFrame: Primary measure definitions with concept references and data type specifications\ntime_dimension::Union{NamedTuple, Nothing}: Special time dimension information if present in the dataflow\n\nExamples\n\n# Extract schema from SDMX-ML\nschema = extract_dataflow_schema(\"SPC\", \"DF_BP50\", \"1.0\")\n\n# Access dataflow information\nprintln(\"Dataflow: \", schema.dataflow_info.name)\nprintln(\"Agency: \", schema.dataflow_info.agency)\n\n# Examine dimensions\nprintln(\"Number of dimensions: \", nrow(schema.dimensions))\nprintln(\"Dimension names: \", schema.dimensions.concept_id)\n\n# Check for time dimension\nif schema.time_dimension !== nothing\n    println(\"Time dimension: \", schema.time_dimension.concept_id)\nend\n\n# Review attributes\nrequired_attrs = filter(row -> row.assignment_status == \"Mandatory\", schema.attributes)\nprintln(\"Required attributes: \", required_attrs.concept_id)\n\nSee also\n\nextract_dataflow_schema\n\n\n\n\n\n","category":"type"},{"location":"api/utilities/#Utility-Functions","page":"Utilities","title":"Utility Functions","text":"","category":"section"},{"location":"api/utilities/","page":"Utilities","title":"Utilities","text":"Helper functions for working with SDMX data and URLs.","category":"page"},{"location":"api/utilities/#URL-Utilities","page":"Utilities","title":"URL Utilities","text":"","category":"section"},{"location":"api/utilities/#SDMX.is_url","page":"Utilities","title":"SDMX.is_url","text":"is_url(input::String) -> Bool\n\nDetects if a string represents a URL using robust pattern matching.\n\nThis function uses multiple patterns to identify various URL formats commonly encountered when working with SDMX APIs. It distinguishes URLs from XML content to enable automatic handling of different input types.\n\nArguments\n\ninput::String: String to test for URL format\n\nReturns\n\nBool: true if input appears to be a URL, false otherwise\n\nExamples\n\n# Various URL formats recognized\nis_url(\"https://example.com\")  # true\nis_url(\"http://stats.pacificdata.org/rest/\")  # true\nis_url(\"www.example.com\")  # true\nis_url(\"example.com/data\")  # true\nis_url(\"ftp://files.example.com\")  # true\n\n# Non-URL content rejected\nis_url(\"<xml>content</xml>\")  # false\nis_url(\"plain text\")  # false\nis_url(\"\")  # AssertionError\n\nThrows\n\nAssertionError: If input string is empty\n\nSee also\n\nnormalize_sdmx_url, fetch_sdmx_xml\n\n\n\n\n\n","category":"function"},{"location":"api/utilities/#SDMX.normalize_sdmx_url","page":"Utilities","title":"SDMX.normalize_sdmx_url","text":"normalize_sdmx_url(url::String) -> String\n\nNormalizes URLs for SDMX API compatibility with required parameters.\n\nThis function ensures URLs have proper protocols and includes the SDMX references=all parameter needed for complete structure retrieval. It handles various URL formats and existing query parameters correctly.\n\nArguments\n\nurl::String: URL to normalize (must be a valid URL)\n\nReturns\n\nString: Normalized URL with protocol and SDMX parameters\n\nExamples\n\n# Add missing protocol\nnormalize_sdmx_url(\"stats.pacificdata.org/rest/datastructure\")\n# Returns: \"https://stats.pacificdata.org/rest/datastructure?references=all\"\n\n# Add SDMX parameter to existing URL\nnormalize_sdmx_url(\"https://api.example.com/structure\")\n# Returns: \"https://api.example.com/structure?references=all\"\n\n# Handle existing query parameters\nnormalize_sdmx_url(\"https://api.example.com/structure?format=xml\")\n# Returns: \"https://api.example.com/structure?format=xml&references=all\"\n\n# Already normalized URLs unchanged\nnormalize_sdmx_url(\"https://api.example.com/structure?references=all\")\n# Returns: \"https://api.example.com/structure?references=all\"\n\nThrows\n\nAssertionError: If URL is empty or not a valid URL format\n\nSee also\n\nis_url, fetch_sdmx_xml\n\n\n\n\n\n","category":"function"},{"location":"api/utilities/#SDMX.fetch_sdmx_xml","page":"Utilities","title":"SDMX.fetch_sdmx_xml","text":"fetch_sdmx_xml(input::String) -> String\n\nFetches SDMX XML content from URLs or validates XML strings.\n\nThis function provides unified handling for SDMX content retrieval, automatically detecting whether the input is a URL (which it fetches) or XML content (which it validates and returns). URLs are automatically normalized for SDMX compatibility.\n\nArguments\n\ninput::String: Either a URL to fetch from or XML content string\n\nReturns\n\nString: XML content from URL or validated input XML string\n\nExamples\n\n# Fetch from SDMX REST API\nxml_content = fetch_sdmx_xml(\"https://stats-sdmx-disseminate.pacificdata.org/rest/datastructure/SPC/DF_BP50\")\n\n# Handle various URL formats\nxml_content = fetch_sdmx_xml(\"stats.pacificdata.org/rest/datastructure/SPC/DF_BP50\")\n\n# Pass through XML content\nxml_string = \"<?xml version=\\\"1.0\\\"?>...>\"\nxml_content = fetch_sdmx_xml(xml_string)  # Returns xml_string unchanged\n\n# Error handling\ntry\n    xml_content = fetch_sdmx_xml(invalid_url)\ncatch e\n    println(\"Failed to fetch XML: \", e)\nend\n\nThrows\n\nAssertionError: For empty input, HTTP failures, empty responses, or invalid XML\n\nSee also\n\nis_url, normalize_sdmx_url\n\n\n\n\n\n","category":"function"},{"location":"api/utilities/#Time-Utilities","page":"Utilities","title":"Time Utilities","text":"","category":"section"},{"location":"api/utilities/#SDMX.is_valid_time_format","page":"Utilities","title":"SDMX.is_valid_time_format","text":"is_valid_time_format(time_str::String) -> Bool\n\nChecks if a time string follows valid SDMX time formats.\n\n\n\n\n\n","category":"function"},{"location":"api/utilities/#SDMX.get_time_period_values","page":"Utilities","title":"SDMX.get_time_period_values","text":"get_time_period_values(time_node::EzXML.Node) -> Vector{String}\n\nGets time period values as strings for dimension analysis.\n\n\n\n\n\n","category":"function"},{"location":"api/utilities/#SDMX.get_time_period_range","page":"Utilities","title":"SDMX.get_time_period_range","text":"get_time_period_range(time_coverage::TimeAvailability) -> Union{UnitRange{Int}, Vector{String}, Vector{Date}}\n\nReturns an appropriate range or vector of time periods based on the format.\n\nExamples\n\ntime_coverage = get_time_coverage(availability)\nperiods = get_time_period_range(time_coverage)\n\n# For annual data: returns 1970:2030\n# For quarterly data: returns [\"2020-Q1\", \"2020-Q2\", ..., \"2023-Q4\"]\n# For daily data: returns Date range\n\n\n\n\n\n","category":"function"},{"location":"api/utilities/#Node-Processing","page":"Utilities","title":"Node Processing","text":"","category":"section"},{"location":"api/utilities/#SDMX.process_code_node","page":"Utilities","title":"SDMX.process_code_node","text":"process_code_node(code_node::EzXML.Node) -> Vector{NamedTuple}\n\nExtracts comprehensive information from a single SDMX code node including multilingual content.\n\nThis function processes an individual code element from an SDMX codelist, extracting the code identifier, names in multiple languages, annotations, and hierarchical  parent relationships. Returns separate records for each language variant found.\n\nArguments\n\ncode_node::EzXML.Node: The SDMX code XML node to process\n\nReturns\n\nVector{NamedTuple}: Vector of code records, one per language, each containing:\ncode_id::String: The code identifier\nlanguage::String: Language code (e.g., \"en\", \"fr\")\nname::Union{String, Missing}: Code name in this language\nannotation::Union{String, Missing}: Code annotation/description in this language\nparent_id::Union{String, Missing}: Parent code identifier if hierarchical\n\nExamples\n\n# Process individual code node\ncode_records = process_code_node(code_node)\n\n# Access multilingual information\nfor record in code_records\n    println(\"Code: \", record.code_id)\n    println(\"Language: \", record.language)\n    println(\"Name: \", record.name)\n    if !ismissing(record.parent_id)\n        println(\"Parent: \", record.parent_id)\n    end\nend\n\n# Filter for specific language\nenglish_record = filter(r -> r.language == \"en\", code_records)[1]\nprintln(\"English name: \", english_record.name)\n\nSee also\n\nget_parent_id\n\n\n\n\n\n","category":"function"},{"location":"api/utilities/#SDMX.get_parent_id","page":"Utilities","title":"SDMX.get_parent_id","text":"get_parent_id(code_node::EzXML.Node) -> Union{String, Missing}\n\nExtracts the parent code identifier from an SDMX code node's hierarchical structure.\n\nThis function searches for parent relationships in SDMX codelist hierarchies by examining the <structure:Parent/Ref> XML element and extracting the referenced parent code identifier, enabling hierarchical code analysis and navigation.\n\nArguments\n\ncode_node::EzXML.Node: The SDMX code XML node to examine for parent references\n\nReturns\n\nUnion{String, Missing}: Parent code identifier if found, missing if no parent exists\n\nExamples\n\n# Extract parent ID from hierarchical code\nparent_id = get_parent_id(code_node)\n\nif !ismissing(parent_id)\n    println(\"Code has parent: \", parent_id)\nelse\n    println(\"This is a top-level code\")\nend\n\n# Use in codelist processing\nfor code_node in code_nodes\n    parent = get_parent_id(code_node)\n    code_id = code_node[\"id\"]\n    println(\"Code \", code_id, \" -> Parent: \", parent)\nend\n\nSee also\n\nprocess_code_node\n\n\n\n\n\n","category":"function"},{"location":"api/utilities/#SDMX.extract_codes_from_codelist_node","page":"Utilities","title":"SDMX.extract_codes_from_codelist_node","text":"extract_codes_from_codelist_node(cl_node::EzXML.Node) -> Vector{NamedTuple}\n\nExtracts all code data from a single <structure:Codelist> node. It finds the codelist's ID and merges it with the data extracted from each child Code node.\n\nArguments\n\ncl_node::EzXML.Node: The codelist node to process.\n\nReturns\n\nVector{NamedTuple}: A vector of named tuples with code and codelist information.\n\n\n\n\n\n","category":"function"},{"location":"api/utilities/#SDMX.extract_availability_from_node","page":"Utilities","title":"SDMX.extract_availability_from_node","text":"extract_availability_from_node(constraint_node::EzXML.Node) -> AvailabilityConstraint\n\nExtracts availability constraint information from a ContentConstraint XML node. This is the core extraction logic used by both extractavailability and extractavailabilityfromdataflow.\n\n\n\n\n\n","category":"function"},{"location":"api/utilities/#Data-Extraction","page":"Utilities","title":"Data Extraction","text":"","category":"section"},{"location":"api/utilities/#SDMX.extract_dimension_values","page":"Utilities","title":"SDMX.extract_dimension_values","text":"extract_dimension_values(kv_node::EzXML.Node) -> Vector{String}\n\nExtracts all available values for a dimension from a KeyValue node.\n\n\n\n\n\n","category":"function"},{"location":"api/utilities/#SDMX.extract_time_availability","page":"Utilities","title":"SDMX.extract_time_availability","text":"extract_time_availability(time_node::EzXML.Node) -> TimeAvailability\n\nExtracts time coverage information from a TIME_PERIOD KeyValue node.\n\n\n\n\n\n","category":"function"},{"location":"api/availability/#Data-Availability","page":"Availability","title":"Data Availability","text":"","category":"section"},{"location":"api/availability/","page":"Availability","title":"Availability","text":"Functions for analyzing data availability constraints and temporal coverage.","category":"page"},{"location":"api/availability/#Main-Functions","page":"Availability","title":"Main Functions","text":"","category":"section"},{"location":"api/availability/#SDMX.extract_availability","page":"Availability","title":"SDMX.extract_availability","text":"extract_availability(url::String) -> AvailabilityConstraint\n\nExtracts availability constraint information from an SDMX availability URL.\n\nExample\n\n# For Pacific Data Hub\navailability = extract_availability(\"https://stats-sdmx-disseminate.pacificdata.org/rest/availableconstraint/DF_DISABILITY/\")\n\n\n\n\n\nextract_availability(doc::EzXML.Document) -> AvailabilityConstraint\n\nExtracts availability constraint information from a parsed XML document.\n\n\n\n\n\n","category":"function"},{"location":"api/availability/#SDMX.extract_availability_from_dataflow","page":"Availability","title":"SDMX.extract_availability_from_dataflow","text":"extract_availability_from_dataflow(doc::EzXML.Document) -> Union{AvailabilityConstraint, Nothing}\n\nExtracts the Actual type ContentConstraint from a dataflow document's Constraints section. This is used when fetching codelists without a specific filtering key.\n\nReturns nothing if no Actual ContentConstraint is found (which is okay - not all dataflows have it).\n\n\n\n\n\n","category":"function"},{"location":"api/availability/#SDMX.get_available_values","page":"Availability","title":"SDMX.get_available_values","text":"get_available_values(availability::AvailabilityConstraint, dimension_id::String) -> Vector{String}\n\nGets available values for a specific dimension.\n\nExample\n\ncountries = get_available_values(availability, \"GEO_PICT\")\nindicators = get_available_values(availability, \"INDICATOR\")\n\n\n\n\n\n","category":"function"},{"location":"api/availability/#SDMX.get_time_coverage","page":"Availability","title":"SDMX.get_time_coverage","text":"get_time_coverage(availability::AvailabilityConstraint; frequency_aware::Bool=true) -> Union{TimeAvailability, Nothing}\n\nGets time coverage information if available. When frequency_aware is true, adjusts the  representation based on the FREQ dimension if present, following SDMX time period formats.\n\nSDMX Time Period Formats\n\nA: Annual (YYYY) - e.g., 2010\nS: Semester/half year (YYYY-Sn) - e.g., 2010-S1\nT: Trimester (YYYY-Tn) - e.g., 2010-T1\nQ: Quarterly (YYYY-Qn) - e.g., 2010-Q1\nM: Monthly (YYYY-MM) - e.g., 2010-01\nD: Daily (YYYY-MM-DD) - e.g., 2010-01-01\nH: Hourly (YYYY-MM-DDThh) - e.g., 2010-01-01T13\nI: DateTime (YYYY-MM-DDThh:mm:ss) - e.g., 2010-01-01T20:22:00\n\nArguments\n\navailability: The availability constraint\nfrequency_aware: Whether to adjust representation based on frequency (default: true)\n\nExamples\n\n# For annual data (FREQ=\"A\"), returns years instead of full dates\ntime_coverage = get_time_coverage(availability)\n# TimeAvailability with start_date=1970, end_date=2030, format=\"year\"\n\n# Force date representation regardless of frequency\ntime_coverage = get_time_coverage(availability, frequency_aware=false)\n\n\n\n\n\n","category":"function"},{"location":"api/availability/#Analysis-Functions","page":"Availability","title":"Analysis Functions","text":"","category":"section"},{"location":"api/availability/#SDMX.compare_schema_availability","page":"Availability","title":"SDMX.compare_schema_availability","text":"compare_schema_availability(schema::DataflowSchema, availability::AvailabilityConstraint) -> Dict{String, Any}\n\nCompares theoretical schema possibilities with actual data availability.\n\nReturns coverage ratios, missing values, and data gaps analysis.\n\n\n\n\n\n","category":"function"},{"location":"api/availability/#SDMX.get_data_coverage_summary","page":"Availability","title":"SDMX.get_data_coverage_summary","text":"get_data_coverage_summary(availability::AvailabilityConstraint) -> DataFrame\n\nCreates a summary DataFrame of data coverage by dimension.\n\n\n\n\n\n","category":"function"},{"location":"api/availability/#SDMX.find_data_gaps","page":"Availability","title":"SDMX.find_data_gaps","text":"find_data_gaps(availability::AvailabilityConstraint, expected_values::Dict{String, Vector{String}}) -> Dict{String, Vector{String}}\n\nIdentifies missing values by comparing availability with expected values.\n\nArguments\n\navailability: The availability constraint\nexpected_values: Dict mapping dimension_id to expected value lists\n\nReturns\n\nDict mapping dimension_id to missing values\n\n\n\n\n\n","category":"function"},{"location":"api/availability/#SDMX.print_availability_summary","page":"Availability","title":"SDMX.print_availability_summary","text":"print_availability_summary(availability::AvailabilityConstraint)\n\nPrints a human-readable summary of the availability constraint.\n\n\n\n\n\n","category":"function"},{"location":"api/availability/#Types","page":"Availability","title":"Types","text":"","category":"section"},{"location":"api/availability/#SDMX.AvailabilityConstraint","page":"Availability","title":"SDMX.AvailabilityConstraint","text":"AvailabilityConstraint\n\nComplete availability constraint information from SDMX.\n\n\n\n\n\n","category":"type"},{"location":"api/availability/#SDMX.DimensionAvailability","page":"Availability","title":"SDMX.DimensionAvailability","text":"DimensionAvailability\n\nAvailability information for a single dimension.\n\n\n\n\n\n","category":"type"},{"location":"api/availability/#SDMX.TimeAvailability","page":"Availability","title":"SDMX.TimeAvailability","text":"TimeAvailability\n\nStructure containing comprehensive information about actual time period coverage in SDMX datasets.\n\nThis struct captures detailed temporal availability information from SDMX availability constraints, including date ranges, format specifications, period counts, and data gaps to provide complete temporal coverage analysis.\n\nFields\n\nstart_date::Union{Date, String}: Earliest available time period in the dataset\nend_date::Union{Date, String}: Latest available time period in the dataset\nformat::String: Time period format (\"date\", \"year\", \"quarter\", \"month\", etc.)\ntotal_periods::Int: Total number of distinct time periods with data\ngaps::Vector{String}: Missing time periods within the overall range\n\nExamples\n\n# Create time availability information\ntime_availability = TimeAvailability(\n    Date(\"2020-01-01\"),\n    Date(\"2023-12-31\"),\n    \"year\", \n    4,\n    [\"2021\"]\n)\n\n# Access coverage information\nprintln(\"Data available from: \", time_availability.start_date)\nprintln(\"Data available to: \", time_availability.end_date)\nprintln(\"Total periods: \", time_availability.total_periods)\n\n# Check for gaps\nif !isempty(time_availability.gaps)\n    println(\"Missing periods: \", join(time_availability.gaps, \", \"))\nend\n\nSee also\n\nAvailabilityConstraint, extract_availability, get_time_coverage\n\n\n\n\n\n","category":"type"},{"location":"getting_started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"getting_started/#Installation","page":"Getting Started","title":"Installation","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Install SDMX.jl from the Julia package registry:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"using Pkg\nPkg.add(\"SDMX\")","category":"page"},{"location":"getting_started/#Basic-Workflow","page":"Getting Started","title":"Basic Workflow","text":"","category":"section"},{"location":"getting_started/#1.-Extract-SDMX-Schema","page":"Getting Started","title":"1. Extract SDMX Schema","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"The first step is to extract the dataflow schema from an SDMX-ML document or API endpoint:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"using SDMX\n\nurl = \"https://stats-sdmx-disseminate.pacificdata.org/rest/dataflow/SPC/DF_BP50/latest?references=all\"\nschema = extract_dataflow_schema(url)\n\n# Inspect the schema\nprintln(\"Dimensions: \", length(schema.dimensions))\nprintln(\"Measures: \", length(schema.measures))\nprintln(\"Attributes: \", length(schema.attributes))","category":"page"},{"location":"getting_started/#2.-Extract-Codelists","page":"Getting Started","title":"2. Extract Codelists","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Extract codelists that define valid values for dimensions:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"# Get all codelists\nall_codelists = extract_all_codelists(url, false)\n\n# Or get only codelists filtered by availability\navailable_codelists = extract_all_codelists(url, true)\n\n# Access specific codelist\ngeo_codes = available_codelists[available_codelists.codelist_id .== \"CL_GEO_PICT\", :]","category":"page"},{"location":"getting_started/#3.-Analyze-Data-Availability","page":"Getting Started","title":"3. Analyze Data Availability","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Understand what data is available:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"availability = extract_availability_from_dataflow(url)\n\n# Get available values for a dimension\ncountry_values = get_available_values(availability, \"GEO_PICT\")\n\n# Get time coverage\ntime_range = get_time_coverage(availability)","category":"page"},{"location":"getting_started/#4.-Validate-Data","page":"Getting Started","title":"4. Validate Data","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Validate your data against the SDMX schema:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"using CSV, DataFrames\n\n# Create validator\nvalidator = create_validator(schema, available_codelists)\n\n# Validate CSV file\nresult = validate_sdmx_csv(validator, \"my_data.csv\")\n\n# Check results\nif result.is_valid\n    println(\"Data is valid!\")\nelse\n    println(\"Validation errors:\")\n    for error in result.errors\n        println(\"  \", error.message)\n    end\nend","category":"page"},{"location":"getting_started/#5.-Query-Data","page":"Getting Started","title":"5. Query Data","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Construct and execute SDMX API queries:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"# Build a data query\ndata_url = construct_data_url(\n    \"https://stats-sdmx-disseminate.pacificdata.org\",\n    \"SPC\", \"DF_BP50\",\n    dimensions = Dict(\"GEO_PICT\" => \"FJ\", \"INDICATOR\" => \"BP_CA_P6_BAL_BP6\")\n)\n\n# Fetch data\ndata = fetch_sdmx_data(data_url)","category":"page"},{"location":"getting_started/#Using-Pipelines","page":"Getting Started","title":"Using Pipelines","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"SDMX.jl supports functional pipeline operations:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"# Chain operations\nresult = schema |>\n    s -> create_validator(s, codelists) |>\n    v -> validate_sdmx_csv(v, \"data.csv\")\n\n# Or use the pipe operator\nusing SDMX: ⇒\n\nschema ⇒ validate_with(codelists, \"data.csv\")","category":"page"},{"location":"getting_started/#Next-Steps","page":"Getting Started","title":"Next Steps","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Explore the API Reference for detailed function documentation\nCheck out Examples for more use cases\nFor LLM-powered data transformation, see SDMXLLM.jl","category":"page"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/#Complete-Workflow-Example","page":"Examples","title":"Complete Workflow Example","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"This example demonstrates a complete workflow from schema extraction to data validation:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using SDMX, CSV, DataFrames\n\n# Define SDMX API endpoint\nurl = \"https://stats-sdmx-disseminate.pacificdata.org/rest/dataflow/SPC/DF_BP50/latest?references=all\"\n\n# 1. Extract schema\nschema = extract_dataflow_schema(url)\n\n# 2. Get codelists with availability filtering\ncodelists = extract_all_codelists(url, true)\n\n# 3. Get data availability\navailability = extract_availability_from_dataflow(url)\nprintln(\"Available countries: \", join(get_available_values(availability, \"GEO_PICT\"), \", \"))\n\n# 4. Load your data\nmy_data = CSV.read(\"my_data.csv\", DataFrame)\n\n# 5. Create validator\nvalidator = create_validator(schema, codelists)\n\n# 6. Validate\nresult = validate_sdmx_csv(validator, \"my_data.csv\")\n\n# 7. Generate report\nreport = generate_validation_report(result)\nprintln(report)","category":"page"},{"location":"examples/#Working-with-Pacific-Data-Hub","page":"Examples","title":"Working with Pacific Data Hub","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Example using the Pacific Data Hub SDMX API:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using SDMX\n\n# Balance of Payments dataflow\nbp_url = \"https://stats-sdmx-disseminate.pacificdata.org/rest/dataflow/SPC/DF_BP50/latest?references=all\"\nbp_schema = extract_dataflow_schema(bp_url)\n\n# Query specific data\nquery_url = construct_data_url(\n    \"https://stats-sdmx-disseminate.pacificdata.org\",\n    \"SPC\", \"DF_BP50\",\n    dimensions = Dict(\n        \"GEO_PICT\" => \"FJ+TV\",  # Fiji and Tuvalu\n        \"FREQ\" => \"A\"            # Annual frequency\n    ),\n    start_period = \"2020\",\n    end_period = \"2023\"\n)\n\ndata = fetch_sdmx_data(query_url)","category":"page"},{"location":"examples/#Codelist-Analysis","page":"Examples","title":"Codelist Analysis","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Working with hierarchical codelists:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using SDMX\n\nurl = \"https://stats-sdmx-disseminate.pacificdata.org/rest/dataflow/SPC/DF_BP50/latest?references=all\"\n\n# Get all codelists\ncodelists = extract_all_codelists(url, false)\n\n# Find specific codelist\ngeo_codelist = codelists[codelists.codelist_id .== \"CL_GEO_PICT\", :]\n\n# Examine hierarchical structure\nfor row in eachrow(geo_codelist)\n    indent = row.parent_id === missing ? \"\" : \"  \"\n    println(indent, row.code_id, \" - \", row.name)\nend","category":"page"},{"location":"examples/#Validation-with-Custom-Rules","page":"Examples","title":"Validation with Custom Rules","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Create a validator with custom validation rules:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using SDMX\n\nschema = extract_dataflow_schema(url)\ncodelists = extract_all_codelists(url, true)\n\n# Create validator\nvalidator = create_validator(schema, codelists)\n\n# Validate with preview\nresult = validate_sdmx_csv(validator, \"data.csv\")\n\n# Preview the output\npreview = preview_validation_output(result; max_rows=10)\nprintln(preview)","category":"page"},{"location":"examples/#Pipeline-Operations","page":"Examples","title":"Pipeline Operations","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Using functional pipeline style:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using SDMX\n\n# Define a validation pipeline\nvalidation_pipeline = pipeline(\n    extract_dataflow_schema,\n    s -> (s, extract_all_codelists(url, true)),\n    ((s, c),) -> create_validator(s, c),\n    v -> validate_sdmx_csv(v, \"data.csv\")\n)\n\n# Execute pipeline\nresult = validation_pipeline(url)","category":"page"},{"location":"examples/#Data-Coverage-Analysis","page":"Examples","title":"Data Coverage Analysis","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Analyze temporal and dimensional coverage:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using SDMX\n\nurl = \"https://stats-sdmx-disseminate.pacificdata.org/rest/dataflow/SPC/DF_BP50/latest?references=all\"\n\n# Get availability\navailability = extract_availability_from_dataflow(url)\n\n# Get coverage summary\nsummary = get_data_coverage_summary(availability, schema)\nprintln(\"Data coverage: \", summary[\"coverage_percentage\"], \"%\")\n\n# Find gaps\ngaps = find_data_gaps(availability, schema)\nif !isempty(gaps)\n    println(\"Data gaps found in: \", join(gaps, \", \"))\nend","category":"page"},{"location":"examples/#Querying-Multiple-Series","page":"Examples","title":"Querying Multiple Series","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Query multiple data series at once:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using SDMX, DataFrames\n\n# Define multiple queries\nqueries = [\n    Dict(\"GEO_PICT\" => \"FJ\", \"INDICATOR\" => \"BP_CA_P6_BAL_BP6\"),\n    Dict(\"GEO_PICT\" => \"TV\", \"INDICATOR\" => \"BP_CA_P6_BAL_BP6\"),\n    Dict(\"GEO_PICT\" => \"VU\", \"INDICATOR\" => \"BP_CA_P6_BAL_BP6\")\n]\n\n# Fetch all\nall_data = DataFrame()\nfor q in queries\n    url = construct_data_url(\n        \"https://stats-sdmx-disseminate.pacificdata.org\",\n        \"SPC\", \"DF_BP50\",\n        dimensions = q\n    )\n    data = fetch_sdmx_data(url)\n    append!(all_data, data)\nend","category":"page"},{"location":"api/queries/#Data-Queries","page":"Data Queries","title":"Data Queries","text":"","category":"section"},{"location":"api/queries/","page":"Data Queries","title":"Data Queries","text":"Functions for constructing and executing SDMX REST API queries.","category":"page"},{"location":"api/queries/#Main-Functions","page":"Data Queries","title":"Main Functions","text":"","category":"section"},{"location":"api/queries/#SDMX.construct_data_url","page":"Data Queries","title":"SDMX.construct_data_url","text":"construct_data_url(base_url::String, agency_id::String, dataflow_id::String, version::String; kwargs...) -> String\n\nConstructs SDMX data query URLs with flexible filtering options.\n\nThis function builds complete SDMX REST API data query URLs according to the SDMX 2.1 standard, supporting various filtering approaches including pre-built keys, schema-based dimension filtering, and time period constraints.\n\nArguments\n\nbase_url::String: SDMX REST API base URL  \nagency_id::String: Data provider agency (e.g., \"SPC\", \"ECB\", \"OECD\")\ndataflow_id::String: Dataflow identifier (e.g., \"DF_BP50\", \"EXR\", \"QNA\")\nversion::String: Dataflow version (e.g., \"1.0\" or \"latest\")\nschema::Union{DataflowSchema,Nothing}=nothing: Optional schema for key construction\nkey::String=\"\": Pre-constructed key string (overrides dimension_filters)\ndimension_filters::Dict{String,String}=Dict{String,String}(): Dimension name-value pairs\nstart_period::Union{String,Nothing}=nothing: Start date/period for time filtering\nend_period::Union{String,Nothing}=nothing: End date/period for time filtering\ndimension_at_observation::String=\"AllDimensions\": Response structure format\n\nReturns\n\nString: Complete SDMX REST API data query URL\n\nExamples\n\n# Using pre-constructed key (most flexible)\nurl = construct_data_url(\n    \"https://stats-sdmx-disseminate.pacificdata.org/rest\",\n    \"SPC\", \"DF_BP50\", \"1.0\",\n    key=\"A.TO.BX_TRF_PWKR._T._T._T._T._T._T._T....\",\n    start_period=\"2022\"\n)\n\n# Using dimension filters with schema validation\nurl = construct_data_url(\n    \"https://sdw-wsrest.ecb.europa.eu/service\",\n    \"ECB\", \"EXR\", \"1.0\", \n    schema=schema,\n    dimension_filters=Dict(\"FREQ\" => \"D\", \"CURRENCY\" => \"USD\"),\n    start_period=\"2023-01\"\n)\n\n# Simple case - get all data with time filtering\nurl = construct_data_url(\n    \"https://stats-sdmx-disseminate.pacificdata.org/rest\",\n    \"SPC\", \"DF_BP50\", \"1.0\",\n    start_period=\"2022\"\n)\n\nSee also\n\nconstruct_sdmx_key, fetch_sdmx_data, query_sdmx_data\n\n\n\n\n\n","category":"function"},{"location":"api/queries/#SDMX.fetch_sdmx_data","page":"Data Queries","title":"SDMX.fetch_sdmx_data","text":"fetch_sdmx_data(url::String; timeout::Int=30) -> DataFrame\n\nFetches and parses SDMX data in CSV format from REST API endpoints.\n\nThis function retrieves SDMX data using the standard SDMX-CSV format, performs basic data cleaning and type conversion, and returns a structured DataFrame suitable for analysis. Works with any SDMX 2.1 compliant provider.\n\nArguments\n\nurl::String: Complete SDMX REST API data query URL\ntimeout::Int=30: HTTP timeout in seconds\n\nReturns\n\nDataFrame: Cleaned dataset with appropriate column types\n\nExamples\n\n# Pacific Data Hub\nurl = construct_data_url(\"https://stats-sdmx-disseminate.pacificdata.org/rest\", \n                        \"SPC\", \"DF_BP50\", \"1.0\", start_period=\"2022\")\ndata = fetch_sdmx_data(url)\n\n# ECB exchange rates with custom timeout\nurl = construct_data_url(\"https://sdw-wsrest.ecb.europa.eu/service\",\n                        \"ECB\", \"EXR\", \"1.0\", \n                        dimension_filters=Dict(\"FREQ\" => \"D\", \"CURRENCY\" => \"USD\"))\ndata = fetch_sdmx_data(url; timeout=60)\n\n# Handle empty responses gracefully\ndata = fetch_sdmx_data(url)\nif nrow(data) == 0\n    println(\"No data available for query\")\nend\n\nThrows\n\nArgumentError: For HTTP errors, invalid responses, or network issues\n\nSee also\n\nconstruct_data_url, clean_sdmx_data, query_sdmx_data\n\n\n\n\n\n","category":"function"},{"location":"api/queries/#SDMX.query_sdmx_data","page":"Data Queries","title":"SDMX.query_sdmx_data","text":"query_sdmx_data(base_url::String, agency_id::String, dataflow_id::String, version::String=\"latest\"; kwargs...) -> DataFrame\n\nConvenience function for complete SDMX data retrieval in a single call.\n\nThis high-level function combines URL construction and data fetching into a single operation, providing the most convenient way to retrieve SDMX data from any provider. It handles URL building, HTTP requests, and data cleaning automatically.\n\nArguments\n\nbase_url::String: SDMX REST API base URL\nagency_id::String: Data provider agency identifier\ndataflow_id::String: Dataflow identifier\nversion::String=\"latest\": Dataflow version\nkey::String=\"\": Pre-constructed SDMX key\nfilters::Dict{String,<:Any}: Combined filters including dimensions and TIME_PERIOD\nDimension values can be String or Vector{String} for multiple values\nTIME_PERIOD can be a single value, array, or range format \"start:end\"\ndimension_filters::Dict{String,<:Any}: Dimension filters (deprecated, use filters)\nstart_period::Union{String,Nothing}=nothing: Start date/period filter\nend_period::Union{String,Nothing}=nothing: End date/period filter\n\nReturns\n\nDataFrame: Cleaned SDMX data ready for analysis\n\nExamples\n\n# Pacific Data Hub - multiple countries with time range\ndata = query_sdmx_data(\n    \"https://stats-sdmx-disseminate.pacificdata.org/rest\",\n    \"SPC\", \"DF_BP50\",\n    filters=Dict(\"GEO_PICT\" => [\"FJ\", \"VU\"], \"TIME_PERIOD\" => \"2020:2023\")\n)\n\n# Single country, specific year\ndata = query_sdmx_data(\n    \"https://stats-sdmx-disseminate.pacificdata.org/rest\",\n    \"SPC\", \"DF_BP50\",\n    filters=Dict(\"GEO_PICT\" => \"TO\", \"TIME_PERIOD\" => \"2022\")\n)\n\n# ECB - EUR/USD daily exchange rates\ndata = query_sdmx_data(\n    \"https://sdw-wsrest.ecb.europa.eu/service\",\n    \"ECB\", \"EXR\", \"1.0\",\n    filters=Dict(\"FREQ\" => \"D\", \"CURRENCY\" => \"USD\", \"CURRENCY_DENOM\" => \"EUR\"),\n    start_period=\"2024-01-01\"\n)\n\n# OECD - using pre-constructed key\ndata = query_sdmx_data(\n    \"https://stats.oecd.org/restsdmx/sdmx.ashx\",\n    \"OECD\", \"QNA\", \"1.0\",\n    key=\"AUS.GDP.CPC.Y.L\",  # Australia, GDP, Current prices, Yearly, Levels\n    start_period=\"2020\"\n)\n\n# Handle potential empty results\ndata = query_sdmx_data(base_url, agency, dataflow, version)\nprintln(\"Retrieved \", nrow(data), \" observations\")\n\nSee also\n\nconstruct_data_url, fetch_sdmx_data, summarize_data\n\n\n\n\n\n","category":"function"},{"location":"api/queries/#Utilities","page":"Data Queries","title":"Utilities","text":"","category":"section"},{"location":"api/queries/#SDMX.construct_sdmx_key","page":"Data Queries","title":"SDMX.construct_sdmx_key","text":"construct_sdmx_key(schema::DataflowSchema, filters::Dict{String,String}) -> String\n\nConstructs a proper SDMX key using dataflow schema dimension ordering.\n\nThis function builds an SDMX data key by ordering dimensions according to the schema definition and validates that all filter dimensions exist in the schema. The resulting key follows SDMX standards with dot-separated dimension values.\n\nArguments\n\nschema::DataflowSchema: DataflowSchema containing dimension definitions and order\nfilters::Dict{String,String}: Dict mapping dimension names to filter values\n\nReturns\n\nString: Properly formatted SDMX key with dimensions in correct order\n\nExamples\n\n# Get schema first\nxml_doc = read_sdmx_structure(url)\nschema = extract_dataflow_schema(xml_doc)\n\n# Construct key with validation\nfilters = Dict(\"FREQ\" => \"A\", \"GEO_PICT\" => \"TO\")\nkey = construct_sdmx_key(schema, filters)\n# Returns: \"A.TO...\" (proper SDMX key based on schema dimension order)\n\nThrows\n\nArgumentError: If any filter dimension is not found in the schema\n\nSee also\n\nconstruct_data_url, get_dimension_order\n\n\n\n\n\nconstruct_sdmx_key(schema::DataflowSchema, filters::Dict{String,<:Any}) -> String\n\nConstructs a proper SDMX key with support for multiple values per dimension.\n\nThis method handles filters with array values, automatically converting them to SDMX '+' notation for multiple selections.\n\nArguments\n\nschema::DataflowSchema: DataflowSchema containing dimension definitions and order\nfilters::Dict{String,<:Any}: Dict with String or Vector{String} values\n\nExamples\n\n# With multiple values\nfilters = Dict(\"GEO_PICT\" => [\"FJ\", \"VU\"], \"FREQ\" => \"A\")\nkey = construct_sdmx_key(schema, filters)\n# Returns: \"A..FJ+VU...\" (with '+' for multiple values)\n\n\n\n\n\n","category":"function"},{"location":"api/queries/#SDMX.clean_sdmx_data","page":"Data Queries","title":"SDMX.clean_sdmx_data","text":"clean_sdmx_data(data::DataFrame) -> DataFrame\n\nPerforms standardized cleaning and type conversion on SDMX-CSV data.\n\nThis function applies standard SDMX data cleaning procedures including numeric conversion of observation values, string formatting of time periods, and removal of empty rows. Works with CSV output from any SDMX 2.1 compliant provider.\n\nArguments\n\ndata::DataFrame: Raw DataFrame from SDMX-CSV parsing\n\nReturns\n\nDataFrame: Cleaned DataFrame with standardized column types\n\nExamples\n\n# Manual cleaning after CSV import\nraw_data = CSV.read(\"sdmx_data.csv\", DataFrame)\ncleaned_data = clean_sdmx_data(raw_data)\n\n# Automatic cleaning within fetch_sdmx_data\ndata = fetch_sdmx_data(url)  # Cleaning applied automatically\n\nSee also\n\nfetch_sdmx_data\n\n\n\n\n\n","category":"function"},{"location":"api/queries/#SDMX.summarize_data","page":"Data Queries","title":"SDMX.summarize_data","text":"summarize_data(data::DataFrame) -> Dict{String, Any}\n\nProvides comprehensive statistical summary of SDMX datasets.\n\nThis function generates a summary report containing key statistics about an SDMX dataset including observation counts, time range coverage, value statistics, and dimension value distributions. Works with data from any SDMX provider.\n\nArguments\n\ndata::DataFrame: SDMX dataset to summarize\n\nReturns\n\nDict{String, Any}: Summary statistics including observation counts, time ranges, and dimension values\n\nExamples\n\ndata = query_sdmx_data(base_url, \"SPC\", \"DF_BP50\", \"1.0\")\nsummary = summarize_data(data)\n\nprintln(\"Total observations: \", summary[\"total_observations\"])\nprintln(\"Time range: \", summary[\"time_range\"])\nif haskey(summary, \"obs_stats\")\n    println(\"Value range: \", summary[\"obs_stats\"].min, \" - \", summary[\"obs_stats\"].max)\nend\n\n# Check dimensions present in data\nfor (key, values) in summary\n    if isa(values, Vector) && !isempty(values)\n        println(key, \": \", length(values), \" unique values\")\n    end\nend\n\nSee also\n\nquery_sdmx_data, clean_sdmx_data\n\n\n\n\n\n","category":"function"},{"location":"api/validation/#Data-Validation","page":"Validation","title":"Data Validation","text":"","category":"section"},{"location":"api/validation/","page":"Validation","title":"Validation","text":"Functions for validating data against SDMX schemas and standards.","category":"page"},{"location":"api/validation/#Main-Functions","page":"Validation","title":"Main Functions","text":"","category":"section"},{"location":"api/validation/#SDMX.create_validator","page":"Validation","title":"SDMX.create_validator","text":"create_validator(schema::DataflowSchema; \n                strict_mode=false, \n                performance_mode=false,\n                auto_fix_enabled=true) -> SDMXValidator\n\nCreates a comprehensive SDMX validator with default validation rules and configurable behavior.\n\nThis constructor function creates a fully configured SDMXValidator instance loaded with all standard SDMX validation rules. The validator can be customized with different modes and settings to suit specific validation requirements.\n\nArguments\n\nschema::DataflowSchema: The target SDMX dataflow schema that defines validation requirements\n\nKeyword Arguments\n\nstrict_mode=false: Enable strict validation with lower tolerance for issues\nperformance_mode=false: Enable performance mode that skips expensive checks for large datasets\nauto_fix_enabled=true: Enable automatic fixing of correctable validation issues\n\nReturns\n\nSDMXValidator: Configured validator ready for dataset validation\n\nExamples\n\n# Create basic validator\nvalidator = create_validator(schema)\nresult = validator(data)\n\n# Create strict validator for critical data\nstrict_validator = create_validator(\n    schema,\n    strict_mode=true,\n    performance_mode=false,\n    auto_fix_enabled=false\n)\n\n# Create performance-optimized validator for large datasets\nfast_validator = create_validator(\n    schema,\n    strict_mode=false,\n    performance_mode=true,\n    auto_fix_enabled=true\n)\n\nSee also\n\nSDMXValidator, validate_sdmx_csv\n\n\n\n\n\n","category":"function"},{"location":"api/validation/#SDMX.validate_sdmx_csv","page":"Validation","title":"SDMX.validate_sdmx_csv","text":"validate_sdmx_csv(validator::SDMXValidator, \n                  data::DataFrame,\n                  dataset_name::String = \"unknown\") -> ValidationResult\n\nPerforms comprehensive validation of SDMX-CSV data against all configured validation rules.\n\nThis is the main validation function that executes all validation rules in the validator, collects issues, calculates compliance metrics, generates recommendations, and produces a complete validation report with performance statistics.\n\nArguments\n\nvalidator::SDMXValidator: Configured validator containing rules and schema\ndata::DataFrame: The SDMX-CSV dataset to validate\ndataset_name::String = \"unknown\": Name identifier for the dataset in reports\n\nReturns\n\nValidationResult: Comprehensive validation results including issues, scores, and recommendations\n\nExamples\n\n# Basic validation\nvalidator = create_validator(schema)\nresult = validate_sdmx_csv(validator, data, \"my_dataset\")\n\n# Check results\nprintln(\"Overall score: \", result.overall_score * 100, \"%\")\nprintln(\"Status: \", result.compliance_status)\nprintln(\"Issues found: \", length(result.issues))\n\n# Generate report\nreport = generate_validation_report(result)\nprintln(report)\n\n# Handle validation issues\ncritical_issues = filter(i -> i.severity == CRITICAL, result.issues)\nif !isempty(critical_issues)\n    println(\"CRITICAL: Dataset cannot be published\")\nend\n\nPerformance Notes\n\nValidation time scales with dataset size and number of enabled rules\nPerformance mode skips expensive checks for large datasets\nRule execution is timed individually for performance analysis\n\nSee also\n\nSDMXValidator, ValidationResult, generate_validation_report\n\n\n\n\n\n","category":"function"},{"location":"api/validation/#SDMX.generate_validation_report","page":"Validation","title":"SDMX.generate_validation_report","text":"generate_validation_report(result::ValidationResult; \n                          format::String = \"text\",\n                          include_details::Bool = true) -> String\n\nGenerates a formatted validation report.\n\n\n\n\n\n","category":"function"},{"location":"api/validation/#SDMX.preview_validation_output","page":"Validation","title":"SDMX.preview_validation_output","text":"preview_validation_output(result::ValidationResult; max_issues::Int = 10) -> String\n\nCreates a concise preview of validation results.\n\n\n\n\n\n","category":"function"},{"location":"api/validation/#Types","page":"Validation","title":"Types","text":"","category":"section"},{"location":"api/validation/#SDMX.ValidationResult","page":"Validation","title":"SDMX.ValidationResult","text":"ValidationResult\n\nComprehensive validation results containing all validation issues, statistics, and actionable recommendations.\n\nThis struct represents the complete output of SDMX-CSV validation, providing detailed analysis of data quality, compliance status, and performance metrics along with specific recommendations for addressing any identified issues.\n\nFields\n\ndataset_name::String: Name or identifier of the validated dataset\nvalidation_timestamp::String: ISO timestamp when validation was performed\ntarget_schema::DataflowSchema: SDMX dataflow schema used for validation\ntotal_rows::Int: Total number of rows in the validated dataset\ntotal_columns::Int: Total number of columns in the validated dataset\nissues::Vector{ValidationIssue}: All validation issues found, ordered by severity\nstatistics::Dict{String, Any}: Detailed validation statistics and metrics\noverall_score::Float64: Overall compliance score (0.0-1.0, higher is better)\ncompliance_status::String: Overall compliance status (\"compliant\", \"minorissues\", \"majorissues\", \"non_compliant\")\nrecommendations::Vector{String}: Prioritized list of actionable recommendations\nperformance_metrics::Dict{String, Float64}: Validation performance timing and efficiency metrics\n\nExamples\n\n# Use validation result\nvalidator = create_validator(schema)\nresult = validate_sdmx_csv(validator, data, \"my_dataset\")\n\n# Check overall compliance\nprintln(\"Dataset score: \", result.overall_score * 100, \"%\")\nprintln(\"Status: \", result.compliance_status)\n\n# Show critical issues\ncritical_issues = filter(i -> i.severity == CRITICAL, result.issues)\nprintln(\"Critical issues: \", length(critical_issues))\n\n# Generate formatted report\nreport = generate_validation_report(result, format=\"text\")\nprintln(report)\n\nSee also\n\nvalidate_sdmx_csv, generate_validation_report\n\n\n\n\n\n","category":"type"},{"location":"api/validation/#SDMX.ValidationRule","page":"Validation","title":"SDMX.ValidationRule","text":"ValidationRule\n\nDefines a single validation rule with its criteria, evaluation logic, and optional auto-fix capabilities.\n\nThis struct encapsulates a complete validation rule that can be applied to SDMX data, including the logic to evaluate the rule, determine severity of violations, and optionally provide automatic fixes for common issues.\n\nFields\n\nrule_id::String: Unique identifier for the validation rule\nrule_name::String: Human-readable name of the validation rule\ndescription::String: Detailed description of what the rule checks\nseverity::ValidationSeverity: Severity level for violations of this rule\ncategory::String: Rule category (\"structure\", \"content\", \"quality\", \"compliance\")\nevaluation_function::Function: Function that evaluates the rule against data\nauto_fix_available::Bool: Whether automatic fixing is available for violations\nauto_fix_function::Union{Function, Nothing}: Function to automatically fix violations, if available\n\nExamples\n\n# Create a structure validation rule\nstructure_rule = ValidationRule(\n    \"REQ_COLS_001\",\n    \"Required Columns Present\",\n    \"Checks that all required SDMX columns are present\",\n    ERROR,\n    \"structure\",\n    (data, schema) -> check_required_columns(data, schema),\n    false,\n    nothing\n)\n\n# Create a rule with auto-fix capability\nformat_rule = ValidationRule(\n    \"FMT_001\",\n    \"Column Name Format\",\n    \"Ensures column names follow SDMX conventions\",\n    WARNING,\n    \"content\",\n    (data, schema) -> check_column_format(data),\n    true,\n    (data) -> fix_column_names(data)\n)\n\n# Use in validator\nvalidator = create_validator(schema)\nadd_custom_validation_rule(validator, structure_rule)\n\nSee also\n\nValidationSeverity, SDMXValidator\n\n\n\n\n\n","category":"type"},{"location":"api/validation/#SDMX.ValidationSeverity","page":"Validation","title":"SDMX.ValidationSeverity","text":"ValidationSeverity\n\nEnumeration for validation issue severity levels in SDMX data validation.\n\nThis enum defines the severity levels used to classify validation issues, helping users prioritize which problems to address first. Higher severity levels indicate more critical issues that prevent successful SDMX data processing.\n\nValues\n\nINFO = 1: Informational messages about data characteristics or suggestions\nWARNING = 2: Potential issues that may cause problems but don't prevent processing\nERROR = 3: Clear violations of SDMX standards that should be fixed\nCRITICAL = 4: Severe violations that prevent any further processing\n\nExamples\n\n# Create validation issues with different severities\ninfo_issue = ValidationIssue(\"Data completeness is 95%\", INFO)\nwarning_issue = ValidationIssue(\"Column name doesn't follow convention\", WARNING)\nerror_issue = ValidationIssue(\"Required column missing\", ERROR)\ncritical_issue = ValidationIssue(\"Invalid data structure\", CRITICAL)\n\n# Filter issues by severity\ncritical_issues = filter(issue -> issue.severity == CRITICAL, all_issues)\n\nSee also\n\nValidationRule, ValidationResult, SDMXValidator\n\n\n\n\n\n","category":"type"},{"location":"api/validation/#SDMX.SDMXValidator","page":"Validation","title":"SDMX.SDMXValidator","text":"SDMXValidator\n\nMain validation engine with configurable rules and settings for comprehensive SDMX data validation.\n\nThis mutable struct serves as the central validation engine, containing all the rules, configuration settings, and schema information needed to validate SDMX-CSV datasets. It supports both strict and performance modes, custom thresholds, and auto-fixing capabilities.\n\nFields\n\nschema::DataflowSchema: The target SDMX dataflow schema for validation\nvalidation_rules::Dict{String, ValidationRule}: Collection of validation rules indexed by rule ID\nstrict_mode::Bool: If true, applies stricter validation criteria with lower tolerance for issues\nperformance_mode::Bool: If true, skips expensive validation checks for large datasets\ncustom_thresholds::Dict{String, Float64}: Custom threshold values for validation rules\nauto_fix_enabled::Bool: Whether automatic issue fixing is enabled\n\nExamples\n\n# Create validator with default settings\nvalidator = create_validator(schema)\n\n# Validate a dataset\nresult = validator(data, \"my_dataset\")\n\n# Create validator with custom settings\nvalidator = create_validator(\n    schema, \n    strict_mode=true, \n    performance_mode=false,\n    auto_fix_enabled=true\n)\n\n# Add custom validation rules\ncustom_rule = ValidationRule(\n    \"custom_001\", \"Custom Check\", \"My custom validation\",\n    WARNING, \"quality\", my_validation_function, false, nothing\n)\nadd_custom_validation_rule(validator, custom_rule)\n\nSee also\n\ncreate_validator, validate_sdmx_csv, ValidationRule\n\n\n\n\n\n","category":"type"},{"location":"#SDMX.jl-Documentation","page":"Home","title":"SDMX.jl Documentation","text":"","category":"section"},{"location":"#SDMX.SDMX","page":"Home","title":"SDMX.SDMX","text":"SDMX.jl - A Julia package for reading and parsing SDMX structural metadata into handy structures (e.g., DataFrames).\n\nThis package provides utilities to extract codelists and codes from SDMX-ML XML documents, making it easy to work with SDMX metadata in Julia.\n\n\n\n\n\n","category":"module"},{"location":"","page":"Home","title":"Home","text":"Core Julia package for SDMX (Statistical Data and Metadata eXchange) processing. Extract and analyze structural metadata from SDMX-ML documents.","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Schema Extraction: Parse SDMX dataflow schemas from XML or APIs\nCodelist Processing: Extract and filter codelists with availability constraints\nData Availability Analysis: Understand data coverage and temporal ranges\nValidation Framework: Validate data against SDMX standards\nPipeline Operations: Chain operations with functional programming style\nData Queries: Construct and execute SDMX API queries","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"SDMX\")","category":"page"},{"location":"#Quick-Example","page":"Home","title":"Quick Example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using SDMX, DataFrames\n\n# Extract SDMX schema from API\nurl = \"https://stats-sdmx-disseminate.pacificdata.org/rest/dataflow/SPC/DF_BP50/latest?references=all\"\nschema = extract_dataflow_schema(url)\n\n# Get codelists filtered by availability\ncodelists = extract_all_codelists(url, true)\n\n# Validate data against schema\nvalidator = create_validator(schema, codelists)\nresult = validate_sdmx_csv(validator, \"my_data.csv\")","category":"page"},{"location":"#Package-Structure","page":"Home","title":"Package Structure","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Schema & Metadata: Extract dataflow schemas, concepts, and structures\nCodelists: Process code lists with hierarchical relationships\nAvailability: Analyze data availability and temporal coverage\nValidation: Validate data quality and SDMX compliance\nData Queries: Construct and execute SDMX REST API queries\nPipelines: Functional operations for workflow composition","category":"page"},{"location":"#See-Also","page":"Home","title":"See Also","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SDMXLLM.jl - LLM-powered extension for intelligent data transformation","category":"page"}]
}
